[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Cobrapy中文文档",
    "section": "",
    "text": "前言\n这是cobra使用指南的个人中文翻译\n若您在阅读此文档的过程中发现任何错误或不妥之处，敬请批评指正。很高兴能与大家能够一起学习cobra，欢迎大家一起讨论交流！",
    "crumbs": [
      "前言"
    ]
  },
  {
    "objectID": "getting_started-cn.html",
    "href": "getting_started-cn.html",
    "title": "1  快速上手指南",
    "section": "",
    "text": "1.1 加载模型并检查它\n我们首先从两个最简单的内置模型开始。它们是沙门氏菌的模型，大肠杆菌的模型，以及一个叫做“教材”（textbook）的模型。textbook 模型描述了大肠杆菌的核心代谢。\nimport cobra\nfrom cobra.io import load_model\n\n# \"iJO1366\" and \"salmonella\" are also valid arguments\nmodel = load_model(\"textbook\")\ncobrapy模型里的反应、代谢物和基因是一种叫做 “cobra.DictList”的特殊列表, 并且每一个分别以 cobra.Reaction, cobra.Metabolite 和cobra.Gene为对象。\nprint(len(model.reactions))\nprint(len(model.metabolites))\nprint(len(model.genes))\n\n95\n72\n137\n当我们使用Jupyter notebook时，这些信息将会以表格形式呈现。\nmodel\n\n\n        \n\n\n\nName\ne_coli_core\n\n\nMemory address\n124eb3a3050\n\n\nNumber of metabolites\n72\n\n\nNumber of reactions\n95\n\n\nNumber of genes\n137\n\n\nNumber of groups\n0\n\n\nObjective expression\n1.0*Biomass_Ecoli_core - 1.0*Biomass_Ecoli_core_reverse_2cdba\n\n\nCompartments\ncytosol, extracellular\n就像常规列表一样， DictList中的对象可以通过索引检索。例如，要获得该模型中的第30个反应（ (at index 29 because of 0-indexing):\nmodel.reactions[29]\n\n\n        \n\n\n\n\n\n\n\nReaction identifier\nEX_glu__L_e\n\n\nName\nL-Glutamate exchange\n\n\nMemory address\n0x124ecc53fd0\n\n\nStoichiometry\nglu__L_e --&gt;\nL-Glutamate --&gt;\n\n\nGPR\n\n\n\nLower bound\n0.0\n\n\nUpper bound\n1000.0\n此外，可以使用DictList.get_by_id() 函数按项目的id检索项目。例如，要获得胞质atp代谢产物对象（id为“atp_c”），我们可以执行以下操作：\nmodel.metabolites.get_by_id(\"atp_c\")\n\n\n        \n\n\n\nMetabolite identifier\natp_c\n\n\nName\nATP\n\n\nMemory address\n0x124ecd18c90\n\n\nFormula\nC10H12N5O13P3\n\n\nCompartment\nc\n\n\nIn 13 reaction(s)\nPPS, PYK, Biomass_Ecoli_core, PPCK, GLNS, PFK, ATPS4r, PGK, SUCOAS, GLNabc, ACKr, ATPM, ADK1\n作为额外的收获，具有交互式shell（如IPython）的用户将能够完成制表，列出列表中的元素。虽然这不是大多数代码的推荐行为，因为id中可能存在“-”等字符，但在交互式提示中这非常有用：\nmodel.reactions.EX_glc__D_e.bounds\n\n(-10.0, 1000.0)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>快速上手指南</span>"
    ]
  },
  {
    "objectID": "getting_started-cn.html#反应",
    "href": "getting_started-cn.html#反应",
    "title": "1  快速上手指南",
    "section": "1.2 反应",
    "text": "1.2 反应\n我们将以葡萄糖-6-磷酸异构酶参与的葡萄糖 6-磷酸和果糖 6-磷酸相互转化反应作为演示对象。在我们的测试的模型中，该反应的反应 ID 是 PGI。\n\npgi = model.reactions.get_by_id(\"PGI\")\npgi\n\n\n        \n\n\n\n\n\n\n\nReaction identifier\nPGI\n\n\nName\nglucose-6-phosphate isomerase\n\n\nMemory address\n0x124ecca7c10\n\n\nStoichiometry\ng6p_c &lt;=&gt; f6p_c\nD-Glucose 6-phosphate &lt;=&gt; D-Fructose 6-phosphate\n\n\nGPR\nb4025\n\n\nLower bound\n-1000.0\n\n\nUpper bound\n1000.0\n\n\n\n\n        \n\n\n我们可以将全名和催化的反应视为字符串\n\nprint(pgi.name)\nprint(pgi.reaction)\n\nglucose-6-phosphate isomerase\ng6p_c &lt;=&gt; f6p_c\n\n\n因为 pgi 是可逆的，所以我们可以通过pgi.lower_bound &lt; 0 和 pgi.upper_bound&gt; 0来查看该反应的下限和上限\n\nprint(pgi.lower_bound, \"&lt; pgi &lt;\", pgi.upper_bound)\nprint(pgi.reversibility)\n\n-1000.0 &lt; pgi &lt; 1000.0\nTrue\n\n\n反应的下限和上限被修改时，其可逆性属性也会自动更新。操作边界的首选方法是使用reaction.bounds，例如\n\nold_bounds = pgi.bounds\npgi.bounds = (0, 1000.0)\nprint(pgi.lower_bound, \"&lt; pgi &lt;\", pgi.upper_bound)\nprint(\"Reversibility after modification:\", pgi.reversibility)\npgi.bounds = old_bounds\nprint(\"Reversibility after resetting:\", pgi.reversibility)\n\n0 &lt; pgi &lt; 1000.0\nReversibility after modification: False\nReversibility after resetting: True\n\n\n还可以使用reaction.lower_bound 或 reaction.upper_bound一次修改一个边界。这种方法没有使用 reaction.bounds同时设置两个边界的方法实用，因为用户可能会不小心设置下限高于上限（反之亦然）。如果出现下限高于上限（反之亦然），则会导致错误。\n\nold_bounds = pgi.bounds\nprint('Upper bound prior to setting new lower bound:', pgi.upper_bound)\npgi.lower_bound = 1100\nprint('Upper bound after setting new lower bound:', pgi.upper_bound)\npgi.bounds = old_bounds\n\nUpper bound prior to setting new lower bound: 1000.0\n\n\nValueError: The lower bound must be less than or equal to the upper bound (1100 &lt;= 1000.0).\n\n\n我们需要确保反应是质量平衡的。如果反应不满足质量平衡，则该函数会返回元素；如果它返回为空，则表示反应是质量平衡的。\n\npgi.check_mass_balance()\n\n{}\n\n\n为了添加代谢物，我们传入一个带有代谢物对象及其系数的 dict\n\npgi.add_metabolites({model.metabolites.get_by_id(\"h_c\"): -1})\npgi.reaction\n\n'g6p_c + h_c &lt;=&gt; f6p_c'\n\n\n反应不再保持质量平衡\n\npgi.check_mass_balance()\n\n{'charge': -1.0, 'H': -1.0}\n\n\n我们可以去除代谢物，反应将再次平衡。\n\npgi.subtract_metabolites({model.metabolites.get_by_id(\"h_c\"): -1})\nprint(pgi.reaction)\nprint(pgi.check_mass_balance())\n\ng6p_c &lt;=&gt; f6p_c\n{}\n\n\n也可以从字符串构建反应。但是，在 执行此操作时必须小心，以确保反应 ID 与模型中的反应 ID 匹配。箭头的方向也用于更新上限和下限。\n\npgi.reaction = \"g6p_c --&gt; f6p_c + h_c + green_eggs + ham\"\n\nunknown metabolite 'green_eggs' created\nunknown metabolite 'ham' created\n\n\n\npgi.reaction\n\n'g6p_c --&gt; f6p_c + green_eggs + h_c + ham'\n\n\n\npgi.reaction = \"g6p_c &lt;=&gt; f6p_c\"\npgi.reaction\n\n'g6p_c &lt;=&gt; f6p_c'",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>快速上手指南</span>"
    ]
  },
  {
    "objectID": "getting_started-cn.html#代谢产物",
    "href": "getting_started-cn.html#代谢产物",
    "title": "1  快速上手指南",
    "section": "1.3 代谢产物",
    "text": "1.3 代谢产物\n我们将以胞质 atp 作为我们的代谢物，它在我们的测试模型中的 id 为\"atp_c\"。\n\natp = model.metabolites.get_by_id(\"atp_c\")\natp\n\n\n        \n\n\n\nMetabolite identifier\natp_c\n\n\nName\nATP\n\n\nMemory address\n0x124ecd18c90\n\n\nFormula\nC10H12N5O13P3\n\n\nCompartment\nc\n\n\nIn 13 reaction(s)\nPPS, PYK, Biomass_Ecoli_core, PPCK, GLNS, PFK, ATPS4r, PGK, SUCOAS, GLNabc, ACKr, ATPM, ADK1\n\n\n\n\n\n我们可以直接把代谢物名称和隔室（在本例中为胞质溶胶）以字符串的形式打印出来。\n\nprint(atp.name)\nprint(atp.compartment)\n\nATP\nc\n\n\n我们可以看到 ATP 在我们的模型中是一种带电分子。\n\natp.charge\n\n-4\n\n\n我们也可以看到代谢物的化学式。\n\nprint(atp.formula)\n\nC10H12N5O13P3\n\n\n反应属性给出了使用给定代谢物的所有反应的frozenset 。我们可以用它来计算使用 atp 的反应数量。\n\nlen(atp.reactions)\n\n13\n\n\n葡萄糖 6-磷酸等代谢物将参与较少的反应。\n\nmodel.metabolites.get_by_id(\"g6p_c\").reactions\n\nfrozenset({&lt;Reaction Biomass_Ecoli_core at 0x124ecca4a50&gt;,\n           &lt;Reaction G6PDH2r at 0x124ecc50090&gt;,\n           &lt;Reaction GLCpts at 0x124ece28190&gt;,\n           &lt;Reaction PGI at 0x124ecca7c10&gt;})",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>快速上手指南</span>"
    ]
  },
  {
    "objectID": "getting_started-cn.html#基因",
    "href": "getting_started-cn.html#基因",
    "title": "1  快速上手指南",
    "section": "1.4 基因",
    "text": "1.4 基因\ngene_reaction_rule是该反应活跃的基因要求的布尔值表示，Schellenberger et al 2011 Nature Protocols 6(9):1290-307.GPR作为GPR类存储在反应的GPR中。它的字符串表示形式存储为 Reaction 对象的gene_reaction_rule。\n\ngpr = pgi.gpr\nprint(gpr)\ngpr_string = pgi.gene_reaction_rule\nprint(gpr_string)\n\nb4025\nb4025\n\n\n相应的基因对象也存在。这些对象由反应本身以及模型追踪。\n\npgi.genes\n\nfrozenset({&lt;Gene b4025 at 0x124eccbd1d0&gt;})\n\n\n\npgi_gene = model.genes.get_by_id(\"b4025\")\npgi_gene\n\n\n        \n\n\n\nGene identifier\nb4025\n\n\nName\npgi\n\n\nMemory address\n0x124eccbd1d0\n\n\nFunctional\nTrue\n\n\nIn 1 reaction(s)\nPGI\n\n\n\n\n\n每个基因都追踪它催化的反应。\n\npgi_gene.reactions\n\nfrozenset({&lt;Reaction PGI at 0x124ecca7c10&gt;})\n\n\n如有必要，改变gene_reaction_rule将创建新的基因对象并更新所有关系。\n\npgi.gene_reaction_rule = \"(spam or eggs)\"\npgi.genes\n\nfrozenset({&lt;Gene eggs at 0x124eea1bed0&gt;, &lt;Gene spam at 0x124eea1bfd0&gt;})\n\n\n\npgi_gene.reactions\n\nfrozenset()\n\n\n新创建的基因也能添加到模型中\n\nmodel.genes.get_by_id(\"spam\")\n\n\n        \n\n\n\nGene identifier\nspam\n\n\nName\n\n\n\nMemory address\n0x124eea1bfd0\n\n\nFunctional\nTrue\n\n\nIn 1 reaction(s)\nPGI\n\n\n\n\n\nknock_out_model_genes函数能够评估 GPR，并在反应被敲除时将上限和下限设置为 0。\n\ncobra.manipulation.knock_out_model_genes(\n    model, [\"spam\"])\nprint(\"after 1 KO: %4d &lt; flux_PGI &lt; %4d\" % (pgi.lower_bound, pgi.upper_bound))\n\ncobra.manipulation.knock_out_model_genes(\n    model, [\"eggs\"])\nprint(\"after 2 KO:  %4d &lt; flux_PGI &lt; %4d\" % (pgi.lower_bound, pgi.upper_bound))\n\nafter 1 KO: -1000 &lt; flux_PGI &lt; 1000\nafter 2 KO:     0 &lt; flux_PGI &lt;    0\n\n\n当在上下文中敲除模型基因时，它在离开上下文时会相反。\n很多时候，人们希望对模型进行一些小的更改并评估这些更改的影响。例如，我们可能希望按顺序敲除所有反应，看看这对目标函数有什么影响。一种方法是在每次敲除之前使用 model.copy() 创建模型的新副本。然而，即使使用小型模型，这也是一种非常缓慢的方法，因为模型是相当复杂的对象。更好的做法是进行敲除、优化，然后手动重置反应边界，然后再进行下一个反应。然而，由于这是一个非常常见的场景，cobrapy 允许我们将模型用作上下文，以自动恢复更改。\n\nmodel = load_model('textbook')\nfor reaction in model.reactions[:5]:\n    with model as model:\n        reaction.knock_out()\n        model.optimize()\n        print('%s blocked (bounds: %s), new growth rate %f' %\n              (reaction.id, str(reaction.bounds), model.objective.value))\n\nACALD blocked (bounds: (0, 0)), new growth rate 0.873922\nACALDt blocked (bounds: (0, 0)), new growth rate 0.873922\nACKr blocked (bounds: (0, 0)), new growth rate 0.873922\nACONTa blocked (bounds: (0, 0)), new growth rate -0.000000\nACONTb blocked (bounds: (0, 0)), new growth rate -0.000000\n\n\n如果我们看一下那些被敲击的反应，就会发现它们的界限都被恢复了。\n\n[reaction.bounds for reaction in model.reactions[:5]]\n\n[(-1000.0, 1000.0),\n (-1000.0, 1000.0),\n (-1000.0, 1000.0),\n (-1000.0, 1000.0),\n (-1000.0, 1000.0)]\n\n\n上下文也支持被嵌套\n\nprint('original objective: ', model.objective.expression)\nwith model:\n    model.objective = 'ATPM'\n    print('print objective in first context:', model.objective.expression)\n    with model:\n        model.objective = 'ACALD'\n        print('print objective in second context:', model.objective.expression)\n    print('objective after exiting second context:',\n          model.objective.expression)\nprint('back to original objective:', model.objective.expression)\n\noriginal objective:  1.0*Biomass_Ecoli_core - 1.0*Biomass_Ecoli_core_reverse_2cdba\nprint objective in first context: 1.0*ATPM - 1.0*ATPM_reverse_5b752\nprint objective in second context: 1.0*ACALD - 1.0*ACALD_reverse_fda2b\nobjective after exiting second context: 1.0*ATPM - 1.0*ATPM_reverse_5b752\nback to original objective: 1.0*Biomass_Ecoli_core - 1.0*Biomass_Ecoli_core_reverse_2cdba\n\n\n大多数修改模型的方法都像这样支持，包括添加和去除反应和代谢物以及设定目标。支持的方法和函数在相应的文档中提到了这一点。\n虽然它没有任何实际效果，但为了语法上的方便，也可以使用与上下文外部不同的名称来引用模型。如\n\nwith model as inner:\n    inner.reactions.PFK.knock_out",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>快速上手指南</span>"
    ]
  },
  {
    "objectID": "configuration-cn.html",
    "href": "configuration-cn.html",
    "title": "2  全局配置",
    "section": "",
    "text": "2.1 配置对象\n您可以通过以下方式获取配置对象 1：\nimport cobra\ncobra_config = cobra.Configuration()\n1配置对象是单例。这意味着只能存在一个实例，并且在 COBRApy 中到处都被接受。",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>全局配置</span>"
    ]
  },
  {
    "objectID": "configuration-cn.html#反应边界",
    "href": "configuration-cn.html#反应边界",
    "title": "2  全局配置",
    "section": "2.2 反应边界",
    "text": "2.2 反应边界\n该对象具有以下属性，你可以检查这些属性，也可以根据需要进行更改。\n\ncobra_config.lower_bound\n\n-1000.0\n\n\n\ncobra_config.upper_bound\n\n1000.0\n\n\n\ncobra_config.bounds\n\n(-1000.0, 1000.0)\n\n\n\n2.2.1 更改边界\n你可在反应前修改并使用这些值。\n\ncobra_config.bounds = -10, 20\n\n\ncobra.Reaction(\"R1\")\n\n\n        \n\n\n\n\n\n\n\nReaction identifier\nR1\n\n\nName\n\n\n\nMemory address\n0x1a995d9a150\n\n\nStoichiometry\n--&gt;\n--&gt;\n\n\nGPR\n\n\n\nLower bound\n0.0\n\n\nUpper bound\n20\n\n\n\n\n        \n\n\n请注意，默认情况下，反应是不可逆的。你可以通过取消设置下限参数来更改此行为。\n\ncobra.Reaction(\"R2\", lower_bound=None)\n\n\n        \n\n\n\n\n\n\n\nReaction identifier\nR2\n\n\nName\n\n\n\nMemory address\n0x1a995f25fd0\n\n\nStoichiometry\n&lt;=&gt;\n&lt;=&gt;\n\n\nGPR\n\n\n\nLower bound\n-10\n\n\nUpper bound\n20\n\n\n\n\n        \n\n\n注意：大多数模型都明确定义了反应边界，该边界优先于配置的值。\n\nfrom cobra.io import load_model\n\n\nmodel = load_model(\"textbook\")\n\n\nmodel.reactions.ACt2r\n\n\n        \n\n\n\n\n\n\n\nReaction identifier\nACt2r\n\n\nName\nR acetate reversible transport via proton - symport\n\n\nMemory address\n0x1a995d987d0\n\n\nStoichiometry\nac_e + h_e &lt;=&gt; ac_c + h_c\nAcetate + H+ &lt;=&gt; Acetate + H+\n\n\nGPR\n\n\n\nLower bound\n-1000.0\n\n\nUpper bound\n1000.0",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>全局配置</span>"
    ]
  },
  {
    "objectID": "configuration-cn.html#solver",
    "href": "configuration-cn.html#solver",
    "title": "2  全局配置",
    "section": "2.3 Solver",
    "text": "2.3 Solver\n你可以通过新实例化模型来定义默认求解器。默认求解器取决于您的环境。为了测试 Gurobi、CPLEX 和 GLPK 的可用性。假定 GLPK 始终存在于环境中。\n\nmodel.solver\n\n&lt;optlang.cplex_interface.Model at 0x1a995d8b950&gt;\n\n\n更改Solver\n\ncobra_config.solver = \"glpk_exact\"\n\n\nnew_model = load_model(\"textbook\")\n\n\nnew_model.solver\n\n&lt;optlang.glpk_exact_interface.Model at 0x1a995e65d10&gt;\n\n\n更改全局配置值在工作会话开始时最有用。",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>全局配置</span>"
    ]
  },
  {
    "objectID": "building_model-cn.html",
    "href": "building_model-cn.html",
    "title": "3  构建模型",
    "section": "",
    "text": "3.1 模型、反应和代谢物\n这个简单示例演示了如何创建模型，创建反应，然后将反应添加到模型中。\n我们将使用 STM_1.0 模型中的“3OAS140”反应：\n1.0 malACP[c] + 1.0 h[c] + 1.0 ddcaACP[c] → 1.0 co2[c] + 1.0 ACP[c] + 1.0 3omrsACP[c]\n首先，创建模型和反应。\nfrom cobra import Model, Reaction, Metabolite\nmodel = Model('example_model')\n\nreaction = Reaction('R_3OAS140')\nreaction.name = '3 oxoacyl acyl carrier protein synthase n C140 '\nreaction.subsystem = 'Cell Envelope Biosynthesis'\nreaction.lower_bound = 0.  # This is the default\nreaction.upper_bound = 1000.  # This is the default\n我们也需要创造代谢物。如果我们使用现有模型“Model.get_by_id”来获得适当的代谢物对象。\nACP_c = Metabolite(\n    'ACP_c',\n    formula='C11H21N2O7PRS',\n    name='acyl-carrier-protein',\n    compartment='c')\nomrsACP_c = Metabolite(\n    'M3omrsACP_c',\n    formula='C25H45N2O9PRS',\n    name='3-Oxotetradecanoyl-acyl-carrier-protein',\n    compartment='c')\nco2_c = Metabolite('co2_c', formula='CO2', name='CO2', compartment='c')\nmalACP_c = Metabolite(\n    'malACP_c',\n    formula='C14H22N2O10PRS',\n    name='Malonyl-acyl-carrier-protein',\n    compartment='c')\nh_c = Metabolite('h_c', formula='H', name='H', compartment='c')\nddcaACP_c = Metabolite(\n    'ddcaACP_c',\n    formula='C23H43N2O8PRS',\n    name='Dodecanoyl-ACP-n-C120ACP',\n    compartment='c')\n旁注：SId\n强烈建议反应、代谢物和基因的 ID 是有效的 SBML 标识符 （SId）。SId 是从基本 XML 类型字符串派生的数据类型，但对允许的字符以及这些字符可能出现的顺序有限制 letter ::= ’a’..’z’,’A’..’Z’ digit ::= ’0’..’9’ idChar ::= letter | digit | ’’ SId ::= ( letter | ’’ ) idCharidChar 主要限制是 id 不能以数字开头。使用 SIds 允许序列化到 SBML。此外，通过点语法进行代码补全和对象访问等功能将在 cobrapy 中工作。\n使用代谢物及其化学计量系数的字典可将代谢物添加到反应中。一组代谢物可以一次全部添加，也可以一次添加一个。\nreaction.add_metabolites({\n    malACP_c: -1.0,\n    h_c: -1.0,\n    ddcaACP_c: -1.0,\n    co2_c: 1.0,\n    ACP_c: 1.0,\n    omrsACP_c: 1.0\n})\n\nreaction.reaction  # This gives a string representation of the reaction\n\n'2.0 ddcaACP_c + 2.0 h_c + 2.0 malACP_c --&gt; 2.0 ACP_c + 2.0 M3omrsACP_c + 2.0 co2_c'\ngene_reaction_rule是该反应活跃的基因要求的布尔表示，如 Schellenberger 等人 的研究Schellenberger et al 2011 Nature Protocols 6(9):1290-307. 我们将分配基因反应规则字符串，该字符串将自动创建相应的基因对象。\nreaction.gene_reaction_rule = '( STM2378 or STM1197 )'\nreaction.genes\n\nfrozenset({&lt;Gene STM1197 at 0x1a2c2619f90&gt;, &lt;Gene STM2378 at 0x1a2c261a150&gt;})\n此时，模型仍为空\nprint(f'{len(model.reactions)} reactions initially')\nprint(f'{len(model.metabolites)} metabolites initially')\nprint(f'{len(model.genes)} genes initially')\n\n3 reactions initially\n8 metabolites initially\n2 genes initially\n我们将反应添加到模型中，该模型还将添加所有相关的代谢物和基因\nmodel.add_reactions([reaction])\n\n# The objects have been added to the model\nprint(f'{len(model.reactions)} reactions')\nprint(f'{len(model.metabolites)} metabolites')\nprint(f'{len(model.genes)} genes')\n\nIgnoring reaction 'R_3OAS140' since it already exists.\n\n\n3 reactions\n8 metabolites\n2 genes\n我们可以遍历模型对象来观察内容\n# Iterate through the the objects in the model\nprint(\"Reactions\")\nprint(\"---------\")\nfor x in model.reactions:\n    print(\"%s : %s\" % (x.id, x.reaction))\n\nprint(\"\")\nprint(\"Metabolites\")\nprint(\"-----------\")\nfor x in model.metabolites:\n    print('%9s : %s' % (x.id, x.formula))\n\nprint(\"\")\nprint(\"Genes\")\nprint(\"-----\")\nfor x in model.genes:\n    associated_ids = (i.id for i in x.reactions)\n    print(\"%s is associated with reactions: %s\" %\n          (x.id, \"{\" + \", \".join(associated_ids) + \"}\"))\n\nReactions\n---------\nR_3OAS140 : 2.0 ddcaACP_c + 2.0 h_c + 2.0 malACP_c --&gt; 2.0 ACP_c + 2.0 M3omrsACP_c + 2.0 co2_c\nEX_co2_e : co2_e &lt;=&gt; \nSK_glycogen_c : glycogen_c &lt;=&gt; \n\nMetabolites\n-----------\n malACP_c : C14H22N2O10PRS\n      h_c : H\nddcaACP_c : C23H43N2O8PRS\n    co2_c : CO2\n    ACP_c : C11H21N2O7PRS\nM3omrsACP_c : C25H45N2O9PRS\nglycogen_c : None\n    co2_e : None\n\nGenes\n-----\nSTM1197 is associated with reactions: {R_3OAS140}\nSTM2378 is associated with reactions: {R_3OAS140}",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>构建模型</span>"
    ]
  },
  {
    "objectID": "building_model-cn.html#目标",
    "href": "building_model-cn.html#目标",
    "title": "3  构建模型",
    "section": "3.2 目标",
    "text": "3.2 目标\n最后，我们需要设定模型的目标。在这里，我们只希望这是我们添加的单个反应中通量的最大化，我们通过将反应的标识符分配给模型的“目标”属性来做到这一点。\n\nmodel.objective = 'R_3OAS140'\n\n创建的目标是一个符号代数表达式，我们可以通过打印来检查它\n\nprint(model.objective.expression)\nprint(model.objective.direction)\n\n1.0*R_3OAS140 - 1.0*R_3OAS140_reverse_60acb\nmax\n\n\n这里表明求解器将在正向上最大化通量。",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>构建模型</span>"
    ]
  },
  {
    "objectID": "building_model-cn.html#模型验证",
    "href": "building_model-cn.html#模型验证",
    "title": "3  构建模型",
    "section": "3.3 模型验证",
    "text": "3.3 模型验证\n为了与其他工具进行交换，您可以验证模型并将其导出到 SBML。 有关序列化和可用格式的详细信息，请参阅“读取和写入模型”部分\n\nimport tempfile\nfrom pprint import pprint\nfrom cobra.io import write_sbml_model, validate_sbml_model\nwith tempfile.NamedTemporaryFile(suffix='.xml') as f_sbml:\n    write_sbml_model(model, filename=f_sbml.name)\n    report = validate_sbml_model(filename=f_sbml.name)\n\npprint(report)\n\n(None,\n {'COBRA_CHECK': [],\n  'COBRA_ERROR': ['No SBML model detected in file.'],\n  'COBRA_FATAL': [],\n  'COBRA_WARNING': [],\n  'SBML_ERROR': ['E0 (Error): Operating system (core, L1); File unreadable; '\n                 'File unreadable. '\n                 'C:\\\\Users\\\\ADMINI~1\\\\AppData\\\\Local\\\\Temp\\\\tmpc4e0sees.xml\\n'],\n  'SBML_FATAL': [],\n  'SBML_SCHEMA_ERROR': [],\n  'SBML_WARNING': []})\n\n\n该模型有效，没有 COBRA 或 SBML 错误或警告。",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>构建模型</span>"
    ]
  },
  {
    "objectID": "building_model-cn.html#交换exchange汇sinks和需求demands",
    "href": "building_model-cn.html#交换exchange汇sinks和需求demands",
    "title": "3  构建模型",
    "section": "3.4 交换（exchange）、汇（sinks）和需求（demands）",
    "text": "3.4 交换（exchange）、汇（sinks）和需求（demands）\n可以使用模型的“add_boundary”方法添加边界反应 有三种不同类型的预定义边界反应：交换反应、需求反应和汇反应。它们都是不平衡的伪反应，这意味着它们通过在模型系统中添加或去除代谢物来实现建模功能，但不是基于真实的生物学。交换反应是一种可逆反应，在细胞外区室中增加或去除细胞外代谢物。需求反应是消耗细胞内代谢物的不可逆反应。汇类似于交换，但专门用于细胞内代谢物，即添加或去除细胞内代谢物的可逆反应。\n\nprint(\"exchanges\", model.exchanges)\nprint(\"demands\", model.demands)\nprint(\"sinks\", model.sinks)\n\nexchanges [&lt;Reaction EX_co2_e at 0x1a2c266f190&gt;]\ndemands []\nsinks [&lt;Reaction SK_glycogen_c at 0x1a2c264de50&gt;]\n\n\n边界反应在代谢物上定义。首先，我们在模型中添加两种代谢物，然后 我们定义边界反应。我们将糖原添加到胞质区室“c”中，将 CO2 添加到外部区室“e”。\n\nmodel.add_metabolites([\n    Metabolite(\n    'glycogen_c',\n    name='glycogen',\n    compartment='c'\n    ),\n    Metabolite(\n    'co2_e',\n    name='CO2',\n    compartment='e'\n    ),\n])\n\n\n# create exchange reaction\nmodel.add_boundary(model.metabolites.get_by_id(\"co2_e\"), type=\"exchange\")\n\nValueError: Boundary reaction 'EX_co2_e' already exists.\n\n\n\n# create exchange reaction\nmodel.add_boundary(model.metabolites.get_by_id(\"glycogen_c\"), type=\"sink\")\n\nValueError: Boundary reaction 'SK_glycogen_c' already exists.\n\n\n\n# Now we have an additional exchange and sink reaction in the model\nprint(\"exchanges\", model.exchanges)\nprint(\"sinks\", model.sinks)\nprint(\"demands\", model.demands)\n\nexchanges [&lt;Reaction EX_co2_e at 0x1a2c266f190&gt;]\nsinks [&lt;Reaction SK_glycogen_c at 0x1a2c264de50&gt;]\ndemands []\n\n\n若要创建需求反应而不是接收器，请使用类型“demand”而不是“sink”。\n有关所有边界反应的信息都可以通过模型的属性“边界”获得。\n\n# boundary reactions\nmodel.boundary\n\n[&lt;Reaction EX_co2_e at 0x1a2c266f190&gt;,\n &lt;Reaction SK_glycogen_c at 0x1a2c264de50&gt;]\n\n\n获得所有代谢反应的一个巧妙技巧是\n\n# metabolic reactions\nset(model.reactions) - set(model.boundary)\n\n{&lt;Reaction R_3OAS140 at 0x1a2c2602b90&gt;}",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>构建模型</span>"
    ]
  },
  {
    "objectID": "io-cn.html",
    "href": "io-cn.html",
    "title": "4  读写模型",
    "section": "",
    "text": "4.1 SBML\nSystems Biology Markup Language 是一种基于 XML 的标准格式，用于分发模型，它通过 FBC extension版本 2 支持 COBRA 模型。\nCobrapy 原生支持使用 FBCv2 读取和写入 SBML。请注意，模型中的所有 ID 都必须符合 SBML SID 要求，才能生成有效的 SBML 文件。\nmini_fbc2_path = data_dir / \"mini_fbc2.xml\" \nread_sbml_model(str(mini_fbc2_path.resolve()))\nwrite_sbml_model(textbook_model, \"test_fbc2.xml\")\n在FBC 2之前，还有其他用于编码COBRA模型的SBML方言。最主要的一种是“COBRA”方言，它在过去利用SBML文件中的“notes”字段进行编码。\nCobrapy能够使用libsbml进行SBML文件的读写操作，但需单独安装（请参阅安装指南）。在读取模型时，它会自动检测是否使用了FBC扩展。而在写入模型时，可以通过use_fbc_package标志选择使用与否，以便以这种传统的“COBRA”格式保存文件。\n建议安装lxml包，因为它能显著加快解析速度。\nmini_cobra_path = data_dir / \"mini_cobra.xml\" \nread_sbml_model(str(mini_cobra_path.resolve()))\nwrite_sbml_model(textbook_model, \"test_cobra.xml\")",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>读写模型</span>"
    ]
  },
  {
    "objectID": "io-cn.html#json",
    "href": "io-cn.html#json",
    "title": "4  读写模型",
    "section": "4.2 JSON",
    "text": "4.2 JSON\nCobrapy 模型具有 JSON（JavaScript 对象表示法）表示形式。创建此格式是为了与 escher 的互操作性。\n\nmini_json_path = data_dir / \"mini.json\" \nload_json_model(str(mini_json_path.resolve()))\n\n\nsave_json_model(textbook_model, \"test.json\")",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>读写模型</span>"
    ]
  },
  {
    "objectID": "io-cn.html#yaml",
    "href": "io-cn.html#yaml",
    "title": "4  读写模型",
    "section": "4.3 YAML",
    "text": "4.3 YAML\nCobrapy 模型具有 YAML（YAML 不是标记语言）表示形式。创建此格式是为了实现更易读的模型表示和模型之间的自动差异而创建的。\n\nmini_yml_path = data_dir / \"mini.yml\"\nload_yaml_model(str(mini_yml_path.resolve()))\n\n\nsave_yaml_model(textbook_model, \"test.yml\")",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>读写模型</span>"
    ]
  },
  {
    "objectID": "io-cn.html#matlab",
    "href": "io-cn.html#matlab",
    "title": "4  读写模型",
    "section": "4.4 MATLAB",
    "text": "4.4 MATLAB\n通常，导入和导出模型可能只是为了在 cobrapy 和 MATLAB cobra 工具箱中使用相同的模型。MATLAB有自己的“.mat”格式来存储变量。从 python 读取和写入这些 mat 文件需要 scipy。\n一个 mat 文件可以包含多个 MATLAB 变量。因此，可以将MATLAB文件中模型的变量名称传递到读取函数中：\n\nmini_mat_path = data_dir / \"mini.mat\"\nload_matlab_model(\n    str(mini_mat_path.resolve()),\n    variable_name=\"mini_textbook\",\n)\n\n如果 mat 文件只包含单个模型，cobra 可以确定要从哪个变量中读取，并且不需要 variable_name 参数。\n\nmini_mat_path = data_dir / \"mini.mat\"\nload_matlab_model(str(mini_mat_path.resolve()))\n\n将模型保存到 mat 文件也相对简单\n\nsave_matlab_model(textbook_model, \"test.mat\")",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>读写模型</span>"
    ]
  },
  {
    "objectID": "io-cn.html#pickle",
    "href": "io-cn.html#pickle",
    "title": "4  读写模型",
    "section": "4.5 Pickle",
    "text": "4.5 Pickle\nCobra 模型可以使用 python 序列化格式 pickle 进行序列化。\n请注意，对于大多数用例，通常不建议使用 pickle 格式。JSON、SBML 和 MAT 通常是首选格式。",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>读写模型</span>"
    ]
  },
  {
    "objectID": "simulating-cn.html",
    "href": "simulating-cn.html",
    "title": "5  使用FBA进行模拟",
    "section": "",
    "text": "5.1 运行 FBA\nsolution = model.optimize()\nprint(solution)\n\n&lt;Solution 0.874 at 0x195d0067050&gt;\nModel.optimize()方法会给出一个解决方案（Solution）对象。这个对象包含了几个关键属性：\n例如，在最后一次调用“model.optimize（）”之后，如果优化成功，则其状态将为最佳。如果模型不可行，则会引发错误。\nsolution.objective_value\n\n0.8739215069684279\n可与 cobrapy 一起使用的求解器速度非常快，以至于对于许多中小型模型来说，计算求解的速度甚至比从求解器收集值并将 python 对象转换为它们所需的速度还要快。使用“model.optimize”，我们收集所有反应和代谢物的值，如果重复进行，这可能需要大量时间。如果我们只对单个反应或目标的通量值感兴趣，那么使用“model.slim_optimize”会更快，它只执行优化并返回目标值，由你来获取你可能需要的其他值。\n%%time\nmodel.optimize().objective_value\n\nCPU times: total: 0 ns\nWall time: 1e+03 µs\n\n\n0.8739215069684305\n%%time\nmodel.slim_optimize()\n\nCPU times: total: 0 ns\nWall time: 1e+03 µs\n\n\n0.8739215069684305",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>使用FBA进行模拟</span>"
    ]
  },
  {
    "objectID": "simulating-cn.html#运行-fba",
    "href": "simulating-cn.html#运行-fba",
    "title": "5  使用FBA进行模拟",
    "section": "",
    "text": "objective_value：表示目标函数的优化值，也就是模型追求最大化或最小化的那个数值结果。\nstatus：显示线性规划求解器给出的解决状态，告诉你问题是否得到解决、有没有特殊情况需要留意。\nfluxes：这是一个按照反应标识符来组织的pandas序列，里面记录了每个反应的通量值。通量是指正向反应速率与逆向反应速率之差，直观反映了物质在该反应中的净流动情况。\nshadow_prices：同样是一个pandas序列，不过这次是依据代谢物标识符来排列的，展示了每个代谢物的影子价格。影子价格揭示了在保持目标函数最优的前提下，如果系统可利用的某种代谢物增多或减少一个单位，目标函数值的变化量，有助于理解代谢物的重要性及限制条件。\n\n\n\n\n\n\n\n5.1.1 分析 FBA solutions\n使用FBA求解的模型可以通过使用摘要方法进一步分析，这些方法输出打印文本以快速表示模型行为。对整个模型调用 summary 方法将显示有关模型的输入和输出行为的信息，以及优化的目标。\n\nmodel.summary()\n\nObjective1.0 Biomass_Ecoli_core = 0.8739215069684297Uptake\n\n\n\nMetabolite\nReaction\nFlux\nC-Number\nC-Flux\n\n\n\n\nglc__D_e\nEX_glc__D_e\n10\n6\n100.00%\n\n\nnh4_e\nEX_nh4_e\n4.765\n0\n0.00%\n\n\no2_e\nEX_o2_e\n21.8\n0\n0.00%\n\n\npi_e\nEX_pi_e\n3.215\n0\n0.00%\n\n\n\n\n5.1.1.1 Secretion\n\n\n\nMetabolite\nReaction\nFlux\nC-Number\nC-Flux\n\n\n\n\nco2_e\nEX_co2_e\n-22.81\n1\n100.00%\n\n\nh2o_e\nEX_h2o_e\n-29.18\n0\n0.00%\n\n\nh_e\nEX_h_e\n-17.53\n0\n0.00%\n\n\n\n\n\n\n此外，还可以使用汇总方法检查单个代谢物的输入输出行为。例如，以下命令可用于检查模型的整体氧化还原平衡\n\nmodel.metabolites.nadh_c.summary()\n\nnadh_cC21H27N7O14P2Producing Reactions\n\n\n\nPercent\nFlux\nReaction\nDefinition\n\n\n\n\n13.14%\n5.064\nAKGDH\nakg_c + coa_c + nad_c --&gt; co2_c + nadh_c + succoa_c\n\n\n8.04%\n3.1\nBiomass_Ecoli_core\n1.496 3pg_c + 3.7478 accoa_c + 59.81 atp_c + 0.361 e4p_c + 0.0709 f6p_c + 0.129 g3p_c + 0.205 g6p_c + 0.2557 gln__L_c + 4.9414 glu__L_c + 59.81 h2o_c + 3.547 nad_c + 13.0279 nadph_c + 1.7867 oaa_c + 0.5191 pep_c + 2.8328 pyr_c + 0.8977 r5p_c --&gt; 59.81 adp_c + 4.1182 akg_c + 3.7478 coa_c + 59.81 h_c + 3.547 nadh_c + 13.0279 nadp_c + 59.81 pi_c\n\n\n41.58%\n16.02\nGAPD\ng3p_c + nad_c + pi_c &lt;=&gt; 13dpg_c + h_c + nadh_c\n\n\n13.14%\n5.064\nMDH\nmal__L_c + nad_c &lt;=&gt; h_c + nadh_c + oaa_c\n\n\n24.09%\n9.283\nPDH\ncoa_c + nad_c + pyr_c --&gt; accoa_c + co2_c + nadh_c\n\n\n\n\n5.1.1.2 Consuming Reactions\n\n\n\nPercent\nFlux\nReaction\nDefinition\n\n\n\n\n100.00%\n-38.53\nNADH16\n4.0 h_c + nadh_c + q8_c --&gt; 3.0 h_e + nad_c + q8h2_c\n\n\n\n\n\n\n或者了解主要的能源生产和消费反应\n\nmodel.metabolites.atp_c.summary()\n\natp_cC10H12N5O13P3Producing Reactions\n\n\n\nPercent\nFlux\nReaction\nDefinition\n\n\n\n\n66.58%\n45.51\nATPS4r\nadp_c + 4.0 h_e + pi_c &lt;=&gt; atp_c + h2o_c + 3.0 h_c\n\n\n23.44%\n16.02\nPGK\n3pg_c + atp_c &lt;=&gt; 13dpg_c + adp_c\n\n\n2.57%\n1.758\nPYK\nadp_c + h_c + pep_c --&gt; atp_c + pyr_c\n\n\n7.41%\n5.064\nSUCOAS\natp_c + coa_c + succ_c &lt;=&gt; adp_c + pi_c + succoa_c\n\n\n\n\n5.1.1.3 Consuming Reactions\n\n\n\nPercent\nFlux\nReaction\nDefinition\n\n\n\n\n12.27%\n-8.39\nATPM\natp_c + h2o_c --&gt; adp_c + h_c + pi_c\n\n\n76.46%\n-52.27\nBiomass_Ecoli_core\n1.496 3pg_c + 3.7478 accoa_c + 59.81 atp_c + 0.361 e4p_c + 0.0709 f6p_c + 0.129 g3p_c + 0.205 g6p_c + 0.2557 gln__L_c + 4.9414 glu__L_c + 59.81 h2o_c + 3.547 nad_c + 13.0279 nadph_c + 1.7867 oaa_c + 0.5191 pep_c + 2.8328 pyr_c + 0.8977 r5p_c --&gt; 59.81 adp_c + 4.1182 akg_c + 3.7478 coa_c + 59.81 h_c + 3.547 nadh_c + 13.0279 nadp_c + 59.81 pi_c\n\n\n0.33%\n-0.2235\nGLNS\natp_c + glu__L_c + nh4_c --&gt; adp_c + gln__L_c + h_c + pi_c\n\n\n10.94%\n-7.477\nPFK\natp_c + f6p_c --&gt; adp_c + fdp_c + h_c",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>使用FBA进行模拟</span>"
    ]
  },
  {
    "objectID": "simulating-cn.html#更改目标",
    "href": "simulating-cn.html#更改目标",
    "title": "5  使用FBA进行模拟",
    "section": "5.2 更改目标",
    "text": "5.2 更改目标\n目标函数由客观反应的objective_coefficient属性确定。通常，使用描述构成细胞的代谢物组成的“生物量”函数。\n\nbiomass_rxn = model.reactions.get_by_id(\"Biomass_Ecoli_core\")\n\n目前在模型中，目标中只有一个反应（生物质反应），线性系数为1。\n\nfrom cobra.util.solver import linear_reaction_coefficients\nlinear_reaction_coefficients(model)\n\n{&lt;Reaction Biomass_Ecoli_core at 0x195cff33490&gt;: 1.0}\n\n\n可以通过分配 Model.objective 来更改目标函数，Model.objective 可以是反应对象（或只是它的名称），也可以是 {Reaction： objective_coefficient} 的字典。\n\n# 将目标改为 ATPM\nmodel.objective = \"ATPM\"\n\n# 上界应该是1000，这样我们才能得到实际的最佳值\nmodel.reactions.get_by_id(\"ATPM\").upper_bound = 1000.\nlinear_reaction_coefficients(model)\n\n{&lt;Reaction ATPM at 0x195cff09450&gt;: 1.0}\n\n\n\nmodel.optimize().objective_value\n\n175.00000000000006\n\n\n我们还可以有更复杂的目标，比如二次项。",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>使用FBA进行模拟</span>"
    ]
  },
  {
    "objectID": "simulating-cn.html#运行-fva",
    "href": "simulating-cn.html#运行-fva",
    "title": "5  使用FBA进行模拟",
    "section": "5.3 运行 FVA",
    "text": "5.3 运行 FVA\nFBA不会总是给出独特的解决方案，因为多个通量状态可以达到相同的最佳状态。FVA（或通量变异性分析）找到每个代谢通量处于最佳状态的范围。\n\nimport cobra\nfrom cobra.flux_analysis import flux_variability_analysis\n\n\nflux_variability_analysis(model, model.reactions[:10])\n\n\n\n\n\n\n\n\nminimum\nmaximum\n\n\n\n\nACALD\n-9.375513e-15\n0.000000e+00\n\n\nACALDt\n-1.198454e-14\n0.000000e+00\n\n\nACKr\n-1.832929e-14\n1.039260e-14\n\n\nACONTa\n2.000000e+01\n2.000000e+01\n\n\nACONTb\n2.000000e+01\n2.000000e+01\n\n\nACt2r\n-3.615752e-15\n0.000000e+00\n\n\nADK1\n0.000000e+00\n1.924093e-13\n\n\nAKGDH\n2.000000e+01\n2.000000e+01\n\n\nAKGt2r\n-9.821844e-15\n0.000000e+00\n\n\nALCD2x\n9.994214e-15\n0.000000e+00\n\n\n\n\n\n\n\n设置参数“fraction_of_optimium=0.90”将给出 90% 最佳反应的通量范围。\n\ncobra.flux_analysis.flux_variability_analysis(\n    model, model.reactions[:10], fraction_of_optimum=0.9)\n\n\n\n\n\n\n\n\nminimum\nmaximum\n\n\n\n\nACALD\n-2.692308\n0.000000e+00\n\n\nACALDt\n-2.692308\n0.000000e+00\n\n\nACKr\n-4.117647\n1.039260e-14\n\n\nACONTa\n8.461538\n2.000000e+01\n\n\nACONTb\n8.461538\n2.000000e+01\n\n\nACt2r\n-4.117647\n0.000000e+00\n\n\nADK1\n0.000000\n1.750000e+01\n\n\nAKGDH\n2.500000\n2.000000e+01\n\n\nAKGt2r\n-1.489362\n0.000000e+00\n\n\nALCD2x\n-2.333333\n0.000000e+00\n\n\n\n\n\n\n\n标准FVA可能包含环路，即高绝对通量值，只有在允许它们参与环路时才能很高（一种在体内不会发生的数学伪影）。使用“loopless”参数来避免此类循环。接下来，我们可以在环中看到 FRD7 和 SUCDi 反应，与此同时可使用无环 FVA 来避免这种情况。\n\nloop_reactions = [model.reactions.FRD7, model.reactions.SUCDi]\nflux_variability_analysis(model, reaction_list=loop_reactions, loopless=False)\n\n\n\n\n\n\n\n\nminimum\nmaximum\n\n\n\n\nFRD7\n0.0\n980.0\n\n\nSUCDi\n20.0\n1000.0\n\n\n\n\n\n\n\n\nflux_variability_analysis(model, reaction_list=loop_reactions, loopless=True)\n\n\n\n\n\n\n\n\nminimum\nmaximum\n\n\n\n\nFRD7\n0.0\n0.0\n\n\nSUCDi\n20.0\n20.0\n\n\n\n\n\n\n\n\n5.3.1 在摘要方法中运行 FVA\n通量变异性分析也可以嵌入到对摘要方法的调用中。例如，可以通过以下方式快速找到基材消耗和产物形成的预期变化\n\nmodel.optimize()\nmodel.summary(fva=0.95)\n\nObjective1.0 ATPM = 175.0000000000001Uptake\n\n\n\nMetabolite\nReaction\nFlux\nRange\nC-Number\nC-Flux\n\n\n\n\nglc__D_e\nEX_glc__D_e\n10\n[9.5; 10]\n6\n100.00%\n\n\no2_e\nEX_o2_e\n60\n[55.88; 60]\n0\n0.00%\n\n\n\n\n5.3.1.1 Secretion\n\n\n\nMetabolite\nReaction\nFlux\nRange\nC-Number\nC-Flux\n\n\n\n\nac_e\nEX_ac_e\n0\n[-2.059; 0]\n2\n0.00%\n\n\nacald_e\nEX_acald_e\n0\n[-1.346; 0]\n2\n0.00%\n\n\nakg_e\nEX_akg_e\n0\n[-0.7447; 0]\n5\n0.00%\n\n\nco2_e\nEX_co2_e\n-60\n[-60; -54.17]\n1\n100.00%\n\n\netoh_e\nEX_etoh_e\n0\n[-1.167; 0]\n2\n0.00%\n\n\nfor_e\nEX_for_e\n0\n[-5.833; 0]\n1\n0.00%\n\n\nglu__L_e\nEX_glu__L_e\n0\n[-0.6731; 0]\n5\n0.00%\n\n\nh2o_e\nEX_h2o_e\n-60\n[-60; -54.17]\n0\n0.00%\n\n\nh_e\nEX_h_e\n0\n[-5.833; 0]\n0\n0.00%\n\n\nlac__D_e\nEX_lac__D_e\n0\n[-1.129; 0]\n3\n0.00%\n\n\nnh4_e\nEX_nh4_e\n0\n[0; 0.6731]\n0\n0.00%\n\n\npi_e\nEX_pi_e\n0\n[0; 0.171]\n0\n0.00%\n\n\npyr_e\nEX_pyr_e\n0\n[-1.346; 0]\n3\n0.00%\n\n\nsucc_e\nEX_succ_e\n0\n[-0.875; 0]\n4\n0.00%\n\n\n\n\n\n\n同样，代谢物质量平衡的变异性也可以通过通量变异性分析来检查。\n\nmodel.metabolites.pyr_c.summary(fva=0.95)\n\npyr_cC3H3O3Producing Reactions\n\n\n\nPercent\nFlux\nRange\nReaction\nDefinition\n\n\n\n\n50.00%\n10\n[9.5; 10]\nGLCpts\nglc__D_e + pep_c --&gt; g6p_c + pyr_c\n\n\n0.00%\n0\n[-1.129; 0]\nLDH_D\nlac__D_c + nad_c &lt;=&gt; h_c + nadh_c + pyr_c\n\n\n0.00%\n0\n[0; 8.75]\nME1\nmal__L_c + nad_c --&gt; co2_c + nadh_c + pyr_c\n\n\n0.00%\n0\n[0; 8.75]\nME2\nmal__L_c + nadp_c --&gt; co2_c + nadph_c + pyr_c\n\n\n50.00%\n10\n[1.25; 18.75]\nPYK\nadp_c + h_c + pep_c --&gt; atp_c + pyr_c\n\n\n0.00%\n0\n[-1.346; 0]\nPYRt2\nh_e + pyr_e &lt;=&gt; h_c + pyr_c\n\n\n\n\n5.3.1.2 Consuming Reactions\n\n\n\nPercent\nFlux\nRange\nReaction\nDefinition\n\n\n\n\n0.00%\n0\n[-0.1316; 0]\nBiomass_Ecoli_core\n1.496 3pg_c + 3.7478 accoa_c + 59.81 atp_c + 0.361 e4p_c + 0.0709 f6p_c + 0.129 g3p_c + 0.205 g6p_c + 0.2557 gln__L_c + 4.9414 glu__L_c + 59.81 h2o_c + 3.547 nad_c + 13.0279 nadph_c + 1.7867 oaa_c + 0.5191 pep_c + 2.8328 pyr_c + 0.8977 r5p_c --&gt; 59.81 adp_c + 4.1182 akg_c + 3.7478 coa_c + 59.81 h_c + 3.547 nadh_c + 13.0279 nadp_c + 59.81 pi_c\n\n\n100.00%\n-20\n[-28.75; -13]\nPDH\ncoa_c + nad_c + pyr_c --&gt; accoa_c + co2_c + nadh_c\n\n\n0.00%\n0\n[-5.833; 0]\nPFL\ncoa_c + pyr_c --&gt; accoa_c + for_c\n\n\n0.00%\n0\n[-8.75; 0]\nPPS\natp_c + h2o_c + pyr_c --&gt; amp_c + 2.0 h_c + pep_c + pi_c\n\n\n\n\n\n\n在这些汇总方法中，这些值报告为中心点 +/- FVA 解的范围，由最大值和最小值计算得出。",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>使用FBA进行模拟</span>"
    ]
  },
  {
    "objectID": "simulating-cn.html#运行-pfba",
    "href": "simulating-cn.html#运行-pfba",
    "title": "5  使用FBA进行模拟",
    "section": "5.4 运行 pFBA",
    "text": "5.4 运行 pFBA\n简约的 FBA（通常写成 pFBA）找到一个通量分布，该分布可提供最佳增长率，但使通量总和最小化。这涉及求解两个顺序线性程序，但由 cobrapy 透明地处理。有关pFBA的更多详细信息，请参阅 Lewis et al. (2010).\n\nmodel.objective = 'Biomass_Ecoli_core'\nfba_solution = model.optimize()\npfba_solution = cobra.flux_analysis.pfba(model)\n\n这些函数可能会给出完全不同的目标值，因为 pFBA 显示的目标值定义为 ‘sum（abs（pfba_solution.fluxes.values））’，而标准 FBA 的目标值定义为通过优化反应的加权通量（例如 ‘fba_solution.fluxes[“Biomass_Ecoli_core”]’）。\npFBA 和 FBA 都应在求解器容差范围内为要优化的目标返回相同的结果。例如，对于使反应“Biomass_Ecoli_core”最大化的 FBA 问题：\n\nabs(fba_solution.fluxes[\"Biomass_Ecoli_core\"] - pfba_solution.fluxes[\n    \"Biomass_Ecoli_core\"])\n\n5.551115123125783e-16\n\n\n\nimport numpy as np\nnp.isclose(\n    fba_solution.fluxes[\"Biomass_Ecoli_core\"], \n    pfba_solution.fluxes[\"Biomass_Ecoli_core\"]\n)\n\nTrue",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>使用FBA进行模拟</span>"
    ]
  },
  {
    "objectID": "simulating-cn.html#运行几何fba",
    "href": "simulating-cn.html#运行几何fba",
    "title": "5  使用FBA进行模拟",
    "section": "5.5 运行几何FBA",
    "text": "5.5 运行几何FBA\n几何 FBA 找到一个独特的最佳通量分布，这是可能通量范围的核心。有关几何FBA的更多详细信息，请参阅 K Smallbone, E Simeonidis (2009).\n\ngeometric_fba_sol = cobra.flux_analysis.geometric_fba(model)\ngeometric_fba_sol\n\nOptimal solution with objective value 0.000\n\n\n\n\n\n\nfluxes\nreduced_costs\n\n\n\n\nACALD\n0.000000e+00\n0.0\n\n\nACALDt\n0.000000e+00\n0.0\n\n\nACKr\n1.260427e-13\n0.0\n\n\nACONTa\n6.007250e+00\n0.0\n\n\nACONTb\n6.007250e+00\n0.0\n\n\n...\n...\n...\n\n\nTALA\n1.496984e+00\n0.0\n\n\nTHD2\n0.000000e+00\n0.0\n\n\nTKT1\n1.496984e+00\n0.0\n\n\nTKT2\n1.181498e+00\n0.0\n\n\nTPI\n7.477382e+00\n0.0\n\n\n\n\n95 rows × 2 columns",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>使用FBA进行模拟</span>"
    ]
  },
  {
    "objectID": "deletions-cn.html",
    "href": "deletions-cn.html",
    "title": "6  模拟删除",
    "section": "",
    "text": "6.1 敲除单个基因和反应\n在分析代谢模型时，一个经常被问到的问题是，如果某种反应不允许有任何通量，会发生什么。这可以通过以下方式使用 cobrapy 进行测试\nprint('complete model: ', cobra_model.optimize())\nwith cobra_model:\n    cobra_model.reactions.PFK.knock_out()\n    print('pfk knocked out: ', cobra_model.optimize())\n\ncomplete model:  &lt;Solution 0.874 at 0x2551f601bd0&gt;\npfk knocked out:  &lt;Solution 0.704 at 0x2551f603b50&gt;\n在评估遗传的操作策略时，更有趣的是检查如果给定的基因被敲除会发生什么，因为这样做在冗余的情况下不会影响任何反应，或者如果基因参与多个反应，则会影响更多的反应。\nprint('complete model: ', cobra_model.optimize())\nwith cobra_model:\n    cobra_model.genes.b1723.knock_out()\n    print('pfkA knocked out: ', cobra_model.optimize())\n    cobra_model.genes.b3916.knock_out()\n    print('pfkB knocked out: ', cobra_model.optimize())\n\ncomplete model:  &lt;Solution 0.874 at 0x2551f60ec90&gt;\npfkA knocked out:  &lt;Solution 0.874 at 0x2551f60e590&gt;\npfkB knocked out:  &lt;Solution 0.704 at 0x2551f60e0d0&gt;",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>模拟删除</span>"
    ]
  },
  {
    "objectID": "deletions-cn.html#单次删除",
    "href": "deletions-cn.html#单次删除",
    "title": "6  模拟删除",
    "section": "6.2 单次删除",
    "text": "6.2 单次删除\n在模型上执行所有单基因删除\n\ndeletion_results = single_gene_deletion(cobra_model)\n\n这些也可以只对一部分基因进行\n\nsingle_gene_deletion(cobra_model, cobra_model.genes[:20])\n\n\n\n\n\n\n\n\nids\ngrowth\nstatus\n\n\n\n\n0\n{b1241}\n0.873922\noptimal\n\n\n1\n{b1478}\n0.873922\noptimal\n\n\n2\n{b0727}\n0.858307\noptimal\n\n\n3\n{b2587}\n0.873922\noptimal\n\n\n4\n{b1849}\n0.873922\noptimal\n\n\n5\n{b0474}\n0.873922\noptimal\n\n\n6\n{b2296}\n0.873922\noptimal\n\n\n7\n{b0116}\n0.782351\noptimal\n\n\n8\n{b0351}\n0.873922\noptimal\n\n\n9\n{b3734}\n0.374230\noptimal\n\n\n10\n{b3732}\n0.374230\noptimal\n\n\n11\n{s0001}\n0.211141\noptimal\n\n\n12\n{b3733}\n0.374230\noptimal\n\n\n13\n{b1276}\n0.873922\noptimal\n\n\n14\n{b0118}\n0.873922\noptimal\n\n\n15\n{b0356}\n0.873922\noptimal\n\n\n16\n{b3115}\n0.873922\noptimal\n\n\n17\n{b0726}\n0.858307\noptimal\n\n\n18\n{b3735}\n0.374230\noptimal\n\n\n19\n{b3736}\n0.374230\noptimal\n\n\n\n\n\n\n\n这也可用于反应\n\nsingle_reaction_deletion(cobra_model, cobra_model.reactions[:20])\n\n\n\n\n\n\n\n\nids\ngrowth\nstatus\n\n\n\n\n0\n{ACONTb}\n-1.376403e-15\noptimal\n\n\n1\n{ENO}\n8.053080e-16\noptimal\n\n\n2\n{ACALD}\n8.739215e-01\noptimal\n\n\n3\n{CYTBD}\n2.116629e-01\noptimal\n\n\n4\n{ALCD2x}\n8.739215e-01\noptimal\n\n\n5\n{CS}\n-7.494929e-15\noptimal\n\n\n6\n{D_LACt2}\n8.739215e-01\noptimal\n\n\n7\n{ACKr}\n8.739215e-01\noptimal\n\n\n8\n{ETOHt2r}\n8.739215e-01\noptimal\n\n\n9\n{Biomass_Ecoli_core}\n0.000000e+00\noptimal\n\n\n10\n{AKGt2r}\n8.739215e-01\noptimal\n\n\n11\n{AKGDH}\n8.583074e-01\noptimal\n\n\n12\n{ACALDt}\n8.739215e-01\noptimal\n\n\n13\n{ACONTa}\n-1.405299e-15\noptimal\n\n\n14\n{ACt2r}\n8.739215e-01\noptimal\n\n\n15\n{ATPS4r}\n3.742299e-01\noptimal\n\n\n16\n{EX_ac_e}\n8.739215e-01\noptimal\n\n\n17\n{CO2t}\n4.616696e-01\noptimal\n\n\n18\n{ADK1}\n8.739215e-01\noptimal\n\n\n19\n{ATPM}\n9.166475e-01\noptimal",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>模拟删除</span>"
    ]
  },
  {
    "objectID": "deletions-cn.html#双重删除",
    "href": "deletions-cn.html#双重删除",
    "title": "6  模拟删除",
    "section": "6.3 双重删除",
    "text": "6.3 双重删除\n双重删除以类似的方式运行。\n\ndouble_gene_deletion(\n    cobra_model, cobra_model.genes[-5:]).round(4)\n\n\n\n\n\n\n\n\nids\ngrowth\nstatus\n\n\n\n\n0\n{b2935, b2465}\n0.0000\noptimal\n\n\n1\n{b0008, b2935}\n0.8739\noptimal\n\n\n2\n{b2464}\n0.8739\noptimal\n\n\n3\n{b3919, b2465}\n0.7040\noptimal\n\n\n4\n{b0008}\n0.8739\noptimal\n\n\n5\n{b0008, b2464}\n0.8648\noptimal\n\n\n6\n{b2935, b2464}\n0.8739\noptimal\n\n\n7\n{b2935}\n0.8739\noptimal\n\n\n8\n{b2935, b3919}\n0.7040\noptimal\n\n\n9\n{b3919, b2464}\n0.7040\noptimal\n\n\n10\n{b2464, b2465}\n0.8739\noptimal\n\n\n11\n{b3919}\n0.7040\noptimal\n\n\n12\n{b0008, b2465}\n0.8739\noptimal\n\n\n13\n{b2465}\n0.8739\noptimal\n\n\n14\n{b0008, b3919}\n0.7040\noptimal\n\n\n\n\n\n\n\n默认情况下，双重删除功能将自动使用多重处理，如果可用，则将任务拆分为最多 4 个内核。也可以手动指定内核数。设置使用单个内核将禁用多处理库，这通常有助于调试。\n\nstart = time()  # start timer()\ndouble_gene_deletion(\n    ecoli_model, ecoli_model.genes[:25], processes=2)\nt1 = time() - start\nprint(\"Double gene deletions for 200 genes completed in \"\n      \"%.2f sec with 2 cores\" % t1)\n\nstart = time()  # start timer()\ndouble_gene_deletion(\n    ecoli_model, ecoli_model.genes[:25], processes=1)\nt2 = time() - start\nprint(\"Double gene deletions for 200 genes completed in \"\n      \"%.2f sec with 1 core\" % t2)\n\nprint(\"Speedup of %.2fx\" % (t2 / t1))\n\nDouble gene deletions for 200 genes completed in 5.06 sec with 2 cores\nDouble gene deletions for 200 genes completed in 2.85 sec with 1 core\nSpeedup of 0.56x\n\n\n也可以对反应运行双重删除。\n\ndouble_reaction_deletion(\n    cobra_model, cobra_model.reactions[2:7]).round(4)\n\n\n\n\n\n\n\n\nids\ngrowth\nstatus\n\n\n\n\n0\n{ACKr, ACt2r}\n0.8739\noptimal\n\n\n1\n{ACONTb, ACt2r}\n-0.0000\noptimal\n\n\n2\n{ADK1, ACt2r}\n0.8739\noptimal\n\n\n3\n{ACKr}\n0.8739\noptimal\n\n\n4\n{ACONTa, ACKr}\n0.0000\noptimal\n\n\n5\n{ACONTb, ACONTa}\n-0.0000\noptimal\n\n\n6\n{ADK1, ACONTa}\n-0.0000\noptimal\n\n\n7\n{ACONTb}\n-0.0000\noptimal\n\n\n8\n{ACONTb, ACKr}\n-0.0000\noptimal\n\n\n9\n{ADK1, ACKr}\n0.8739\noptimal\n\n\n10\n{ACONTb, ADK1}\n-0.0000\noptimal\n\n\n11\n{ADK1}\n0.8739\noptimal\n\n\n12\n{ACONTa}\n-0.0000\noptimal\n\n\n13\n{ACt2r}\n0.8739\noptimal\n\n\n14\n{ACONTa, ACt2r}\n-0.0000\noptimal",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>模拟删除</span>"
    ]
  },
  {
    "objectID": "deletions-cn.html#访问单个删除结果",
    "href": "deletions-cn.html#访问单个删除结果",
    "title": "6  模拟删除",
    "section": "6.4 访问单个删除结果",
    "text": "6.4 访问单个删除结果\n请注意，删除的索引是 python set 对象。这是适当的类型，因为删除的顺序无关紧要。删除反应 1 和反应 2 与删除反应 2 和反应 1 的效果相同。\n为了更轻松地访问结果，COBRAPpy 删除函数返回的所有 DataFrame 都有一个 knockout 索引器，使访问变得更加简单。索引器中的每个条目都被视为单个删除条目。因此，您需要传递双重删除的集合。\n\nsingle = single_reaction_deletion(cobra_model)\ndouble = double_reaction_deletion(cobra_model)\n\nprint(single.knockout[\"ATPM\"])\nprint(double.knockout[{\"ATPM\", \"TKT1\"}])\n\n       ids    growth   status\n92  {ATPM}  0.916647  optimal\n             ids   growth   status\n19  {ATPM, TKT1}  0.90584  optimal\n\n\n这可用于一次获得多个删除，也适用于反应或基因对象（取决于您删除的内容）。\n\natpm = cobra_model.reactions.ATPM\ntkt1 = cobra_model.reactions.TKT1\npfk = cobra_model.reactions.PFK\n\nprint(single.knockout[atpm, tkt1, pfk])\nprint(double.knockout[{atpm, tkt1}, {atpm, pfk}, {atpm}])\n\n       ids    growth   status\n60  {TKT1}  0.864759  optimal\n81   {PFK}  0.704037  optimal\n92  {ATPM}  0.916647  optimal\n               ids    growth   status\n19    {ATPM, TKT1}  0.905840  optimal\n1136   {PFK, ATPM}  0.704037  optimal\n3996        {ATPM}  0.916647  optimal",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>模拟删除</span>"
    ]
  },
  {
    "objectID": "phenotype_phase_plane-cn.html",
    "href": "phenotype_phase_plane-cn.html",
    "title": "7  生长包线",
    "section": "",
    "text": "生长包线（又名表型相平面）将显示出不同的最佳生长阶段，使用两种不同的底物。有关详细信息，请参阅 Edwards et al.\nCobrapy 支持计算这些Production envelopes，并且可以使用您喜欢的绘图包轻松绘制它们。在这里，我们将为“教科书”制作一个_E.coli_核心模型，并演示使用matplotlib.\n\nfrom cobra.io import load_model\nfrom cobra.flux_analysis import production_envelope\n\nmodel = load_model(\"textbook\")\n\n我们想制作一个表型相平面来评估葡萄糖和氧气的摄取。\n\nprod_env = production_envelope(model, [\"EX_glc__D_e\", \"EX_o2_e\"])\n\n\nprod_env.head()\n\n\n\n\n\n\n\n\ncarbon_source\nflux_minimum\ncarbon_yield_minimum\nmass_yield_minimum\nflux_maximum\ncarbon_yield_maximum\nmass_yield_maximum\nEX_glc__D_e\nEX_o2_e\n\n\n\n\n0\nEX_glc__D_e\n0.0\n0.0\nNaN\n0.000000\n1.750832e-14\nNaN\n-10.0\n-60.000000\n\n\n1\nEX_glc__D_e\n0.0\n0.0\nNaN\n0.072244\n1.310050e+00\nNaN\n-10.0\n-56.842105\n\n\n2\nEX_glc__D_e\n0.0\n0.0\nNaN\n0.144488\n2.620100e+00\nNaN\n-10.0\n-53.684211\n\n\n3\nEX_glc__D_e\n0.0\n0.0\nNaN\n0.216732\n3.930150e+00\nNaN\n-10.0\n-50.526316\n\n\n4\nEX_glc__D_e\n0.0\n0.0\nNaN\n0.288975\n5.240200e+00\nNaN\n-10.0\n-47.368421\n\n\n\n\n\n\n\n如果我们指定碳源，我们也可以得到碳和质量产量。例如，暂时将目标设置为生产醋酸纤维，我们可以得到如下Production envelopes并且使用pandas来快速绘制结果。\n\nprod_env = production_envelope(\n    model, [\"EX_o2_e\"], objective=\"EX_ac_e\", carbon_sources=\"EX_glc__D_e\")\n\n\nprod_env.head()\n\n\n\n\n\n\n\n\ncarbon_source\nflux_minimum\ncarbon_yield_minimum\nmass_yield_minimum\nflux_maximum\ncarbon_yield_maximum\nmass_yield_maximum\nEX_o2_e\n\n\n\n\n0\nEX_glc__D_e\n0.0\n0.0\n0.0\n0.000000\n5.340670e-16\n5.251029e-16\n-60.000000\n\n\n1\nEX_glc__D_e\n0.0\n0.0\n0.0\n1.578947\n5.263158e-02\n5.174819e-02\n-56.842105\n\n\n2\nEX_glc__D_e\n0.0\n0.0\n0.0\n3.157895\n1.052632e-01\n1.034964e-01\n-53.684211\n\n\n3\nEX_glc__D_e\n0.0\n0.0\n0.0\n4.736842\n1.578947e-01\n1.552446e-01\n-50.526316\n\n\n4\nEX_glc__D_e\n0.0\n0.0\n0.0\n6.315789\n2.105263e-01\n2.069927e-01\n-47.368421\n\n\n\n\n\n\n\n\n%matplotlib inline\n\n\nprod_env.plot(\n    kind='line', x='EX_o2_e', y='carbon_yield_maximum');\n\n\n\n\n\n\n\n\n以前版本的 cobrapy 包括更多定制的相平面图，现在已被删除，以提高可维护性并增强 cobrapy 的焦点。cobra模型的绘图适用于另一个包。",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>生长包线</span>"
    ]
  },
  {
    "objectID": "sampling-cn.html",
    "href": "sampling-cn.html",
    "title": "8  通量取样",
    "section": "",
    "text": "8.1 基本用法\n开始使用通量采样的最简单的方法是在flux_analysis 子模块的sample 功能。sample至少接受俩个参数：cobra模型以及要生成的样本数量。\nfrom cobra.io import load_model\nfrom cobra.sampling import sample\n\nmodel = load_model(\"textbook\")\ns = sample(model, 100)\ns.head()\n\n\n\n\n\n\n\n\nACALD\nACALDt\nACKr\nACONTa\nACONTb\nACt2r\nADK1\nAKGDH\nAKGt2r\nALCD2x\n...\nRPI\nSUCCt2_2\nSUCCt3\nSUCDi\nSUCOAS\nTALA\nTHD2\nTKT1\nTKT2\nTPI\n\n\n\n\n0\n-3.799475\n-2.498751\n-1.421441\n7.540352\n7.540352\n-1.421441\n16.929342\n6.483571\n-0.338296\n-1.300724\n...\n-1.499339\n14.876146\n15.591381\n566.653991\n-6.483571\n1.464935\n1.833969\n1.464935\n1.451100\n8.457706\n\n\n1\n-1.664563\n-1.159660\n-0.104808\n10.096309\n10.096309\n-0.104808\n21.034965\n9.031672\n-0.102474\n-0.504903\n...\n-1.458747\n2.293237\n3.284039\n484.075418\n-9.031672\n1.434034\n48.090638\n1.434034\n1.424095\n7.472630\n\n\n2\n-1.803558\n-1.667910\n-2.144206\n8.824075\n8.824075\n-2.144206\n11.796768\n2.727459\n-0.121884\n-0.135648\n...\n-1.705485\n1.930752\n2.053874\n721.454310\n-2.727459\n1.681770\n75.179992\n1.681770\n1.672234\n7.402820\n\n\n3\n-1.448489\n-0.122990\n-1.631803\n9.828801\n9.828801\n-1.631803\n22.691294\n5.339959\n-0.201254\n-1.325499\n...\n-1.986551\n10.169471\n11.442413\n684.373359\n-5.339959\n1.892144\n36.876984\n1.892144\n1.854180\n7.635212\n\n\n4\n-0.751012\n-0.234146\n-1.534250\n10.996159\n10.996159\n-1.534250\n2.346065\n5.583547\n-0.695630\n-0.516866\n...\n-3.448945\n1.012854\n2.196951\n624.064170\n-5.583547\n3.400375\n19.158341\n3.400375\n3.380843\n6.447869\n\n\n\n\n5 rows × 95 columns\n默认情况下，sample 使用基于此处 method presented here介绍的方法的optgp方法，因为它适用于较大的模型，并且可以并行运行。默认情况下，采样器使用单个进程。这可以通过使用 processes参数进行更改\nprint(\"One process:\")\n%time s = sample(model, 1000)\nprint(\"Two processes:\")\n%time s = sample(model, 1000, processes=2)\n\nOne process:\nCPU times: total: 20.8 s\nWall time: 15.8 s\nTwo processes:\nCPU times: total: 1.92 s\nWall time: 34 s\n或者，您也可以通过将方法设置为“achr”来使用 Artificial Centering Hit-and-Run 进行采样。 ‘achr’ 不支持并行执行，但收敛性好，几乎是马尔可夫式的。\ns = sample(model, 100, method=\"achr\")\n一般来说，设置采样器的成本很高，因为初始搜索方向是通过解决许多线性规划问题生成的。因此，我们建议一次性生成尽可能多的样品。但是，这可能需要对采样过程进行更精细的控制，如下一节所述。",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>通量取样</span>"
    ]
  },
  {
    "objectID": "sampling-cn.html#高级使用方法",
    "href": "sampling-cn.html#高级使用方法",
    "title": "8  通量取样",
    "section": "8.2 高级使用方法",
    "text": "8.2 高级使用方法\n\n8.2.1 采样目标\n通过直接使用采样器类，可以在较低级别上控制采样过程。\n\nfrom cobra.sampling import OptGPSampler, ACHRSampler\n\n这两个采样器类都具有标准化的接口，并采用一些额外的参数。例如，“变薄”因素。“减薄”是指每 n 次迭代仅记录样本。较高的稀化系数意味着较少的相关样本，但计算时间也较长。默认情况下，采样器使用 100 的稀疏因子，这会创建大致不相关的样本。如果您想要更少的样品但更好的混合，请随时增加此参数。如果要研究自己的模型的收敛性，则可能需要将其设置为 1 以获取所有迭代。\n\nachr = ACHRSampler(model, thinning=10)\n\nOptGPSampler有一个额外的 processes参数，用于指定用于创建并行采样链的进程数。这应该按照 CPU 内核的顺序排列，以实现最大效率。如前所述，由于生成初始搜索方向，类初始化可能需要几分钟时间。另一方面，采样速度很快。\n\noptgp = OptGPSampler(model, processes=4)\n\n\n\n8.2.2 采样和验证\n两个采样器都有一个示例函数，该函数从初始化的对象生成样本，其作用类似于上面描述的 sample函数，只是这次它只接受一个参数，即样本数。对于OptGPSampler，样本数应为进程数的倍数，否则将自动增加到最接近的倍数。\n\ns1 = achr.sample(100)\n\ns2 = optgp.sample(100)\n\nYou cansampleamplerepeatedly and both samplers are optimized to generate large amount of samples without falling into \"numerical traps\". All sampler objects have avalidate` function in order to check if a set of points are feasible and give detailed information about feasibility violations in a form of a short code denoting feasibility. Here the short code is a combination of any of the following letters:\n\n“v” - valid point\n“l” - lower bound violation\n“u” - upper bound violation\n“e” - equality violation (meaning the point is not a steady state)\n\nFor instance for a random flux distribution (should not be feasible):\n\nimport numpy as np\n\nbad = np.random.uniform(-1000, 1000, size=len(model.reactions))\nachr.validate(np.atleast_2d(bad))\n\narray(['le'], dtype='&lt;U3')\n\n\n对于我们生成的样本：\n\nachr.validate(s1)\n\narray(['v', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v',\n       'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v',\n       'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v',\n       'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v',\n       'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v',\n       'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v',\n       'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v',\n       'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v', 'v'], dtype='&lt;U3')\n\n\n尽管大多数模型在数值上足够稳定，采样器应该只生成有效样本，但我们仍然敦促检查这一点。validate 非常快，即使对于大型模型和许多样本也能快速工作。如果发现无效样本，则不必重新运行整个样本，但可以从示例 DataFrame 中排除它们。\n\ns1_valid = s1[achr.validate(s1) == \"v\"]\nlen(s1_valid)\n\n100\n\n\n\n\n8.2.3 批量抽样\n采样器对象用于生成数十亿个样本，但是在使用基因组规模模型时，使用“样本”功能可能会很快填满您的 RAM。在这里，采样器对象的sample方法可能会派上用场。 batch 有两个参数，即每批中的样本数和批数。举个小例子，这是有道理的。\n让我们假设我们想要量化样本中将增长的比例。为此，我们可能需要生成 10 批，每批 50 个样本，并测量单个 100 个样本中显示大于 0.1 的百分比。最后，我们要计算这些单个百分比的平均值和标准差。\n\ncounts = [np.mean(s.Biomass_Ecoli_core &gt; 0.1) for s in optgp.batch(100, 10)]\nprint(\"Usually {:.2f}% +- {:.2f}% grow...\".format(\n    np.mean(counts) * 100.0, np.std(counts) * 100.0))\n\nUsually 3.00% +- 0.77% grow...",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>通量取样</span>"
    ]
  },
  {
    "objectID": "sampling-cn.html#添加约束",
    "href": "sampling-cn.html#添加约束",
    "title": "8  通量取样",
    "section": "8.3 添加约束",
    "text": "8.3 添加约束\n通量采样将遵循模型中定义的其他约束条件。例如，我们可以添加一个约束，以与上一节类似的方式强制增长。\n\nco = model.problem.Constraint(model.reactions.Biomass_Ecoli_core.flux_expression, lb=0.1)\nmodel.add_cons_vars([co])\n\n请注意，这仅用于演示目的。通常，您可以直接设置反应的下限，而不是创建新约束。\n\ns = sample(model, 10)\nprint(s.Biomass_Ecoli_core)\n\n0    0.105278\n1    0.126172\n2    0.108318\n3    0.105436\n4    0.100796\n5    0.154830\n6    0.155173\n7    0.177615\n8    0.193415\n9    0.148553\nName: Biomass_Ecoli_core, dtype: float64\n\n\n正如我们所看到的，我们的新约束被接受了。",
    "crumbs": [
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>通量取样</span>"
    ]
  },
  {
    "objectID": "loopless-cn.html",
    "href": "loopless-cn.html",
    "title": "9  无循环FBA",
    "section": "",
    "text": "9.1 无循环解决方案\n由于增加了混合整数约束，下面描述的经典无循环方法在计算上成本很高。一种更快、更实用的方法是对通量分布进行后处理，只需将通量设置为零，只要它们可以为零，而不改变模型中任何交换反应的通量。 CycleFreeFlux 是一种可用于实现此目的的算法，在 cobrapy 中，它是在 cobra.flux_analysis.loopless_solution 函数中实现的。loopless_solution将识别与原始磁通量分布最接近的磁通量分布（仅使用无循环基本磁通模式）。请注意，这不会删除您明确请求的环路，例如通过强制环路反应携带非零通量。\n使用比上面的简单示例更大的模型，可以按如下方式演示\nsalmonella = load_model('salmonella')\nnominal = salmonella.optimize()\nloopless = loopless_solution(salmonella)\nimport pandas\n\ndf = pandas.DataFrame(dict(loopless=loopless.fluxes, nominal=nominal.fluxes))\ndf.plot.scatter(x='loopless', y='nominal')\n\n&lt;Axes: xlabel='loopless', ylabel='nominal'&gt;\n此功能还可以在 FVA 中使用，通过使用 ‘loopless=True’ 参数来避免反应获得高通量范围，这些反应基本上只有在允许它们参与循环时才能达到高通量（参见模拟笔记本），从而导致更窄的通量范围。",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>无循环FBA</span>"
    ]
  },
  {
    "objectID": "loopless-cn.html#无循环模型",
    "href": "loopless-cn.html#无循环模型",
    "title": "9  无循环FBA",
    "section": "9.2 无循环模型",
    "text": "9.2 无循环模型\nCobrapy 还包括 Schellenberger et. al. 的“经典”无循环公式。 在 cobra.flux_analysis.add_loopless中实现，使用额外的混合整数约束修改模型，使热力学上不可行的循环变得不可能。这比上面提供的策略慢得多，并且只有在以下两种情况之一适用时才应使用：\n\n您希望将非线性（例如二次）目标循与无环条件相结合\n您希望强制模型在存在独立于设定的反应边界的循环时不可行。\n\n我用一个玩具模型来演示这一点，该模型有一个，A \\(\\rightarrow\\) B \\(\\rightarrow\\) C \\(\\rightarrow\\) A，w$ A，允许 A 进入系统，允许 C 离开。系统的图形视图如下图所示：\n\nplot_helper.plot_loop()\n\n\n\n\n\n\n\n\n\nmodel = Model()\nmodel.add_metabolites([Metabolite(i) for i in \"ABC\"])\nmodel.add_reactions([Reaction(i) for i in [\"EX_A\", \"DM_C\", \"v1\", \"v2\", \"v3\"]])\n\nmodel.reactions.EX_A.add_metabolites({\"A\": 1})\nmodel.reactions.DM_C.add_metabolites({\"C\": -1})\n\nmodel.reactions.v1.add_metabolites({\"A\": -1, \"B\": 1})\nmodel.reactions.v2.add_metabolites({\"B\": -1, \"C\": 1})\nmodel.reactions.v3.add_metabolites({\"C\": -1, \"A\": 1})\n\nmodel.objective = 'DM_C'\n\n虽然此模型包含一个循环，但存在一个通量状态，该通量状态没有通量通过反应\\(v_3\\)，并由无循环 FBA 标识。\n\nwith model:\n    add_loopless(model)\n    solution = model.optimize()\nprint(\"loopless solution: status = \" + solution.status)\nprint(\"loopless solution flux: v3 = %.1f\" % solution.fluxes[\"v3\"])\n\nloopless solution: status = optimal\nloopless solution flux: v3 = 0.0\n\n\n如果没有通过无循环反应的强制通量，则精简的 FBA 也不会有通量通过环路。\n\nsolution = pfba(model)\nprint(\"parsimonious solution: status = \" + solution.status)\nprint(\"loopless solution flux: v3 = %.1f\" % solution.fluxes[\"v3\"])\n\nparsimonious solution: status = optimal\nloopless solution flux: v3 = 0.0\n\n\n但是，如果通量被强制通过\\(v_3\\)，那么就不再存在可行的无循环解决方案，但简约的解决方案仍将存在。在。\n\nmodel.reactions.v3.lower_bound = 1\nwith model:\n    add_loopless(model)\n    try:\n        solution = model.optimize()\n    except:\n        print('model is infeasible')\n\nd:\\ProgramData\\anaconda3\\Lib\\site-packages\\cobra\\util\\solver.py:554: UserWarning: Solver status is 'infeasible'.\n  warn(f\"Solver status is '{status}'.\", UserWarning)\n\n\n\nsolution = pfba(model)\nprint(\"parsimonious solution: status = \" + solution.status)\nprint(\"loopless solution flux: v3 = %.1f\" % solution.fluxes[\"v3\"])\n\nparsimonious solution: status = optimal\nloopless solution flux: v3 = 1.0",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>无循环FBA</span>"
    ]
  },
  {
    "objectID": "loopless-cn.html#方法",
    "href": "loopless-cn.html#方法",
    "title": "9  无循环FBA",
    "section": "9.3 方法",
    "text": "9.3 方法\nloopless_solution”基于给定的参考通量分布。它将寻找具有以下要求的新的通量分布: 1. 目标值与参考通量相同。 2. 所有交换通量的值都与参考分布中的值相同。 3. 所有非交换通量都具有与参考通量相同的符号（流动方向相同）。 4. 绝对非交换通量的总和最小化。 正如original publication所证明的那样，这将确定最接近参考通量的“最小环路”解决方案。 若您正在使用add_loopless功能，将采用此处描述的方法described here。简而言之，该方法会添加近似于ΔG（反应自由能变化）的代理变量G，并通过热力学手段使循环路径不可行。具体实现通过以下公式：\n          maximize vobj\n          s.t.Sv=0\n          lbj ≤ vj ≤ ubj\n          -M⋅(1-ai) ≤ vi ≤ M⋅ai\n          -1000ai + (1-ai) ≤ Gi ≤ -ai + 1000(1-ai)\n          NintG = 0\n          ai ∈ {0,1}\n这里，索引j遍历所有反应，而i仅针对内部反应。ai是指标变量，若反应通量为正向则等于1，反之为0。它们用来确保G代理变量的符号总是与实际的ΔG值相反。Nint是内部反应的零空间矩阵，用于找到热力学上“合理”的G值。\n换言之，这个方法聪明地利用了一些数学技巧，在保证反应网络不产生闭环的同时，寻找一个在能量效率上最接近自然状态（即参考通量）的解决方案。它通过引入一些虚拟变量和限制条件，让模型自己去判断哪些反应方向更符合现实世界的热力学法则，从而排除掉那些理论上允许但实际上不可能发生的循环路径。",
    "crumbs": [
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>无循环FBA</span>"
    ]
  },
  {
    "objectID": "gapfilling-cn.html",
    "href": "gapfilling-cn.html",
    "title": "10  缺口填充",
    "section": "",
    "text": "模型缺口填充的任务是找出必须将哪些反应添加到模型中以使其可行。已经报道了几种这样的算法，例如Kumar等人，2009和Reed等人，2006。cobry有一个缺口填充实现，与Reed等人的实现非常相似，我们使用混合整数线性程序来计算需要为用户定义的反应集合添加的最小反应数量，即通用模型。简单地说，就是我们尝试的问题\nMinimize: \\[\\sum_i c_i * z_i\\]\nsubject to\n\\[Sv = 0\\] \\[v^\\star \\geq t\\] \\[l_i\\leq v_i \\leq u_i\\] \\[v_i = 0 \\textrm{ if } z_i = 0\\]\n其中l， u分别是i反应的下界和上界，z是一个指标变量，如果不使用该反应则为零，否则为1，c是与使用i反应相关的用户定义成本，\\(v^\\star\\)是物镜的通量，t是该物镜的下界。为了证明这一点，让我们以一个模型为例，并从中移除一些基本的反应。\n\nfrom cobra.io import load_model\nfrom cobra.flux_analysis import gapfill\nmodel = load_model(\"iYS1720\")\n\n在这个模型中，d -果糖-6-磷酸是必需的代谢物。我们将移除所有使用它的反应，并把它们放到一个单独的模型中。\n\nimport cobra\nuniversal = cobra.Model(\"universal_reactions\")\nfor i in [i.id for i in model.metabolites.f6p_c.reactions]:\n    reaction = model.reactions.get_by_id(i)\n    universal.add_reactions([reaction.copy()])\n    model.remove_reactions([reaction])\n\n现在，因为这些空白，所以模型不会发展。\n\nmodel.optimize().objective_value\n\n0.0\n\n\n我们将使用模型的原始目标，生长，来找出哪些被移除的反应是模型再次可行所必需的。这与Kumar et al. 2009的“不增长但增长(NGG)”预测非常相似。\n\nsolution = gapfill(model, universal, demand_reactions=False)\nfor reaction in solution[0]:\n    print(reaction.id)\n\nGF6PTA\nTALA\n\n\n通过多次迭代，我们可以得到多个可能的反应集。\n\nresult = gapfill(model, universal, demand_reactions=False, iterations=4)\nfor i, entries in enumerate(result):\n    print(\"---- Run %d ----\" % (i + 1))\n    for e in entries:\n        print(e.id)\n\n---- Run 1 ----\nGF6PTA\nTALA\n---- Run 2 ----\nGF6PTA\nTALA\n---- Run 3 ----\nGF6PTA\nPGI\nTKT2\n---- Run 4 ----\nGF6PTA\nTALA\n\n\n我们也可以不使用最初的目标，指定一种我们希望模型能够产生的代谢物。\n\nwith model:\n    model.objective = model.add_boundary(model.metabolites.f6p_c, type='demand')\n    solution = gapfill(model, universal)\n    for reaction in solution[0]:\n        print(reaction.id)\n\nPGI\n\n\n最后，请注意，使用混合整数线性规划在计算上相当昂贵，对于较大的模型，您可能需要考虑替代的间隙填充方法和重建方法。",
    "crumbs": [
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>缺口填充</span>"
    ]
  },
  {
    "objectID": "consistency-cn.html",
    "href": "consistency-cn.html",
    "title": "11  一致性测试",
    "section": "",
    "text": "11.1 使用 FVA\n我们可以遵循的第一种方法是使用 FVA（通量可变性分析），在许多其他应用中，它用于检测阻塞反应。 cobra.flux_analysis.find_blocked_reactions() 函数将返回使用 FVA 获得的所有被阻止反应的列表。\ncobra.flux_analysis.find_blocked_reactions(test_model)\n\n['v2']\nAs we see above, we are able to obtain the blocked reaction, which in this case is \\(v_2\\). 正如上述所示，我们能够通过在本例中的 \\(v_2\\)，来获得阻断反应。",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>一致性测试</span>"
    ]
  },
  {
    "objectID": "consistency-cn.html#使用fastcc",
    "href": "consistency-cn.html#使用fastcc",
    "title": "11  一致性测试",
    "section": "11.2 使用FASTCC",
    "text": "11.2 使用FASTCC\n在cobrapy中获得一致网络的第二种方法是使用 FASTCC。使用这种方法，您可以期望有效地获得准确一致的网络。有关该算法的更多详细信息，请参阅Vlassis N, Pacheco MP, Sauter T (2014).\n\nconsistent_model = cobra.flux_analysis.fastcc(test_model)\nconsistent_model.reactions\n\n[&lt;Reaction v1 at 0x21cc26101d0&gt;,\n &lt;Reaction v3 at 0x21cc27caa50&gt;,\n &lt;Reaction v4 at 0x21cc27cabd0&gt;,\n &lt;Reaction v5 at 0x21cc27cad50&gt;,\n &lt;Reaction v6 at 0x21cc27caf10&gt;]\n\n\n与 FVA 方法类似，我们能够确定 \\(v_2\\) 确实是阻断反应。",
    "crumbs": [
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>一致性测试</span>"
    ]
  },
  {
    "objectID": "media-cn.html",
    "href": "media-cn.html",
    "title": "12  生长培养基",
    "section": "",
    "text": "12.1 最小培养基\n在某些情况下，您可能对能够保持特定生长速率的最小生长介质感兴趣，即所谓的最小介质。为此，我们提供了minimal_medium`函数，默认情况下获得具有最低总进口通量的介质。这个函数需要两个参数:模型和其必须达到的最小增长率(或其他目标)。\nfrom cobra.medium import minimal_medium\n\nmax_growth = model.slim_optimize()\nminimal_medium(model, max_growth)\n\nd:\\ProgramData\\anaconda3\\Lib\\site-packages\\cobra\\medium\\minimal_medium.py:112: FutureWarning: The default dtype for empty Series will be 'object' instead of 'float64' in a future version. Specify a dtype explicitly to silence this warning.\n  medium = pd.Series()\n\n\nEX_glc__D_e    10.000000\nEX_nh4_e        4.765319\nEX_o2_e        21.799493\nEX_pi_e         3.214895\ndtype: float64\n所以我们看到生长实际上受到葡萄糖输入的限制。 或者，您可能对具有最少数量的活动导入的最小介质感兴趣。这可以通过使用minimize_components参数来实现(注意，这使用了MIP公式，因此会慢得多)。\nminimal_medium(model, 0.1, minimize_components=True)\n\nd:\\ProgramData\\anaconda3\\Lib\\site-packages\\cobra\\medium\\minimal_medium.py:112: FutureWarning: The default dtype for empty Series will be 'object' instead of 'float64' in a future version. Specify a dtype explicitly to silence this warning.\n  medium = pd.Series()\n\n\nEX_glc__D_e    10.00000\nEX_nh4_e        0.54528\nEX_pi_e         0.36787\ndtype: float64\n在尽量减少进口通量的数量时，可能有许多替代解决方案。为了得到其中的几个，你也可以传递一个正整数来minimize_components，这将给你最多50个备选解。让我们在我们的模型中尝试一下，并使用 open_exchanges 参数，该参数将为模型中的所有进口反应分配一个大的上界。返回类型将是pandas.DataFrame。\nminimal_medium(model, 0.8, minimize_components=8, open_exchanges=True)\n\nd:\\ProgramData\\anaconda3\\Lib\\site-packages\\cobra\\medium\\minimal_medium.py:112: FutureWarning: The default dtype for empty Series will be 'object' instead of 'float64' in a future version. Specify a dtype explicitly to silence this warning.\n  medium = pd.Series()\nd:\\ProgramData\\anaconda3\\Lib\\site-packages\\cobra\\medium\\minimal_medium.py:112: FutureWarning: The default dtype for empty Series will be 'object' instead of 'float64' in a future version. Specify a dtype explicitly to silence this warning.\n  medium = pd.Series()\nd:\\ProgramData\\anaconda3\\Lib\\site-packages\\cobra\\medium\\minimal_medium.py:112: FutureWarning: The default dtype for empty Series will be 'object' instead of 'float64' in a future version. Specify a dtype explicitly to silence this warning.\n  medium = pd.Series()\nd:\\ProgramData\\anaconda3\\Lib\\site-packages\\cobra\\medium\\minimal_medium.py:112: FutureWarning: The default dtype for empty Series will be 'object' instead of 'float64' in a future version. Specify a dtype explicitly to silence this warning.\n  medium = pd.Series()\nd:\\ProgramData\\anaconda3\\Lib\\site-packages\\cobra\\medium\\minimal_medium.py:112: FutureWarning: The default dtype for empty Series will be 'object' instead of 'float64' in a future version. Specify a dtype explicitly to silence this warning.\n  medium = pd.Series()\nd:\\ProgramData\\anaconda3\\Lib\\site-packages\\cobra\\medium\\minimal_medium.py:112: FutureWarning: The default dtype for empty Series will be 'object' instead of 'float64' in a future version. Specify a dtype explicitly to silence this warning.\n  medium = pd.Series()\n\n\n\n\n\n\n\n\n\n0\n1\n2\n3\n4\n5\n\n\n\n\nEX_fru_e\n0.000000\n308.82944\n0.00000\n0.000000\n0.000000\n0.000000\n\n\nEX_glc__D_e\n0.000000\n0.00000\n308.82944\n31.084608\n502.051914\n0.000000\n\n\nEX_gln__L_e\n0.000000\n0.00000\n0.00000\n2.181120\n0.000000\n0.000000\n\n\nEX_glu__L_e\n346.141716\n4.36224\n4.36224\n0.000000\n0.000000\n24.798770\n\n\nEX_mal__L_e\n0.000000\n0.00000\n0.00000\n0.000000\n0.000000\n1000.000000\n\n\nEX_nh4_e\n0.000000\n0.00000\n0.00000\n0.000000\n8.417918\n0.000000\n\n\nEX_o2_e\n500.000000\n0.00000\n0.00000\n0.000000\n0.000000\n0.000000\n\n\nEX_pi_e\n65.104125\n2.94296\n2.94296\n2.942960\n5.679100\n15.546299\n所以总共有4个解。一个好氧和三个厌氧使用不同的碳源。",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>生长培养基</span>"
    ]
  },
  {
    "objectID": "media-cn.html#边界反应",
    "href": "media-cn.html#边界反应",
    "title": "12  生长培养基",
    "section": "12.2 边界反应",
    "text": "12.2 边界反应\n除交换反应外，还有其他类型的边界反应，如需求反应或吸收反应。cobrapy 使用各种启发式方法来识别它们，并且可以通过使用适当的属性来访问它们。对于交换反应:\n\necoli = load_model(\"iJO1366\")\necoli.exchanges[0:5]\n\n[&lt;Reaction EX_12ppd__R_e at 0x21342599f10&gt;,\n &lt;Reaction EX_12ppd__S_e at 0x21342576390&gt;,\n &lt;Reaction EX_14glucan_e at 0x21342576350&gt;,\n &lt;Reaction EX_15dap_e at 0x21342576750&gt;,\n &lt;Reaction EX_23camp_e at 0x21342576b10&gt;]\n\n\n对于需求反应:\n\necoli.demands\n\n[&lt;Reaction DM_4crsol_c at 0x21342573a50&gt;,\n &lt;Reaction DM_5drib_c at 0x21342573bd0&gt;,\n &lt;Reaction DM_aacald_c at 0x21342574450&gt;,\n &lt;Reaction DM_amob_c at 0x21342574810&gt;,\n &lt;Reaction DM_mththf_c at 0x21342574c10&gt;,\n &lt;Reaction DM_oxam_c at 0x21342574fd0&gt;]\n\n\n对于汇反应:\n\necoli.sinks\n\n[]\n\n\n所有边界反应(任何消耗或引入质量到系统中的反应)都可以用boundary属性获得:\n\necoli.boundary[0:10]\n\n[&lt;Reaction DM_4crsol_c at 0x21342573a50&gt;,\n &lt;Reaction DM_5drib_c at 0x21342573bd0&gt;,\n &lt;Reaction DM_aacald_c at 0x21342574450&gt;,\n &lt;Reaction DM_amob_c at 0x21342574810&gt;,\n &lt;Reaction DM_mththf_c at 0x21342574c10&gt;,\n &lt;Reaction DM_oxam_c at 0x21342574fd0&gt;,\n &lt;Reaction EX_12ppd__R_e at 0x21342599f10&gt;,\n &lt;Reaction EX_12ppd__S_e at 0x21342576390&gt;,\n &lt;Reaction EX_14glucan_e at 0x21342576350&gt;,\n &lt;Reaction EX_15dap_e at 0x21342576750&gt;]",
    "crumbs": [
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>生长培养基</span>"
    ]
  },
  {
    "objectID": "solvers-cn.html",
    "href": "solvers-cn.html",
    "title": "13  求解器",
    "section": "",
    "text": "13.1 内部求解器接口\nCobrapy也包含自己的求解器接口，但这些接口现在已被弃用，并将在不久的将来被完全删除。有关如何使用这些工具的文档，请参阅 older documentation.",
    "crumbs": [
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>求解器</span>"
    ]
  },
  {
    "objectID": "constraints_objectives-cn.html",
    "href": "constraints_objectives-cn.html",
    "title": "14  量身定制的约束、变量和目标",
    "section": "",
    "text": "14.1 约束\n假设我们想确保两个反应在模型中有相同的通量。我们可以使用optlang求解器接口将这些标准作为约束添加到模型中，方法是简单地定义相关表达式，如下所示。\nfrom cobra.io import load_model\nmodel = load_model('textbook')\nsame_flux = model.problem.Constraint(\n    model.reactions.FBA.flux_expression - model.reactions.NH4t.flux_expression,\n    lb=0,\n    ub=0)\nmodel.add_cons_vars(same_flux)\n我们感兴趣的反应的通量由model.reactions.FBA.flux_expression获得，它只是正向和反向通量的总和，即，\nmodel.reactions.FBA.flux_expression\n\n1.0*FBA - 1.0*FBA_reverse_84806\n现在我可以最大限度地提高生长速度，而反应“FBA”和“NH4t”的通量被限制为(接近)相同。\nsolution = model.optimize()\nprint(solution.fluxes['FBA'], solution.fluxes['NH4t'],\n      solution.objective_value)\n\n4.662749047738146 4.662749047738147 0.8551109609261567\n也可以一次添加许多约束。对于大型模型，约束涉及许多反应，有效的方法是首先为每个通量构建线性系数字典，然后立即添加约束。例如，假设我们想对网络中每个通量的绝对值之和添加一个约束，使其小于 100：\ncoefficients = dict()\nfor rxn in model.reactions:\n    coefficients[rxn.forward_variable] = 1.\n    coefficients[rxn.reverse_variable] = 1.\nconstraint = model.problem.Constraint(0, lb=0, ub=100)\nmodel.add_cons_vars(constraint)\nmodel.solver.update()\nconstraint.set_linear_coefficients(coefficients=coefficients)",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>量身定制的约束、变量和目标</span>"
    ]
  },
  {
    "objectID": "constraints_objectives-cn.html#对象",
    "href": "constraints_objectives-cn.html#对象",
    "title": "14  量身定制的约束、变量和目标",
    "section": "14.2 对象",
    "text": "14.2 对象\n简单的目标，例如通过一个或多个反应使通量最大化，只需简单即可完成赋值给 model.objective属性，正如我们在前几章中看到的那样，例如，\n\nmodel = load_model('textbook')\nwith model:\n    model.objective = {model.reactions.Biomass_Ecoli_core: 1}\n    model.optimize()\n    print(model.reactions.Biomass_Ecoli_core.flux)\n\n0.8739215069684279\n\n\n目标数学表达式由下式表示\n\nmodel.objective.expression\n\n1.0*Biomass_Ecoli_core - 1.0*Biomass_Ecoli_core_reverse_2cdba\n\n\n但是假设我们需要一个更复杂的目标，比如最小化解到原点的欧氏距离减去另一个变量，同时受到额外的线性约束。这是一个同时具有线性和二次分量的目标函数。\n考虑示例问题：\n\nmin \\(\\frac{1}{2}\\left(x^2 + y^2 \\right) - y\\)\n\n\nsubject to\n\n\n\\(x + y = 2\\)\n\n\n\\(x \\ge 0\\)\n\n\n\\(y \\ge 0\\)\n\n这个（确实人为设定得有些过头）的问题，可以用图形的方式来形象化展示，就好比在一系列可行解决方案构成的直线上，用一个蓝点来标记出最佳解。\n\n%matplotlib inline\nimport plot_helper\n\nplot_helper.plot_qp2()\n\n\n\n\n\n\n\n\n我们回到教科书模型，并将求解器设置为可以处理二次目标(如complex)的求解器。然后我们加上线性约束x和y反应的和，我们设为FBA和NH4t，必须等于2。\n\nimport optlang\nmodel.solver = 'cplex'\nsum_two = model.problem.Constraint(\n    model.reactions.FBA.flux_expression + model.reactions.NH4t.flux_expression,\n    lb=2,\n    ub=2)\nmodel.add_cons_vars(sum_two)\n\nSolverNotFound: cplex is not a valid solver interface. Pick one from glpk_exact, glpk, scipy.\n\n\n接下来我们添加二次目标\n\nquadratic_objective = model.problem.Objective(\n    0.5 * model.reactions.NH4t.flux_expression**2 + 0.5 *\n    model.reactions.FBA.flux_expression**2 -\n    model.reactions.FBA.flux_expression,\n    direction='min')\nmodel.objective = quadratic_objective\nsolution = model.optimize(objective_sense=None)\n\nAttributeError: 'SwigPyObject' object has no attribute 'Objective'\n\n\n\nprint(solution.fluxes['NH4t'], solution.fluxes['FBA'])\n\n4.662749047738147 4.662749047738146",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>量身定制的约束、变量和目标</span>"
    ]
  },
  {
    "objectID": "constraints_objectives-cn.html#变量",
    "href": "constraints_objectives-cn.html#变量",
    "title": "14  量身定制的约束、变量和目标",
    "section": "14.3 变量",
    "text": "14.3 变量\n我们还可以创建额外的变量，以方便研究新的约束和变量的影响。假设我们想研究氮和碳吸收之间的通量差异，同时我们阻止其他反应。为此，添加另一个表示这种差异的变量可能会有所帮助。\n\nmodel = load_model('textbook')\ndifference = model.problem.Variable('difference')\n\n我们使用约束来定义这个变量应采用什么值\n\nconstraint = model.problem.Constraint(\n    model.reactions.EX_glc__D_e.flux_expression -\n    model.reactions.EX_nh4_e.flux_expression - difference,\n    lb=0,\n    ub=0)\nmodel.add_cons_vars([difference, constraint])\n\n现在，我们可以通过查看其原始值，在敲除探索期间直接访问该差异。\n\nfor reaction in model.reactions[:5]:\n    with model:\n        reaction.knock_out()\n        model.optimize()\n        print(model.solver.variables.difference.primal)\n\n-5.234680806802557\n-5.234680806802542\n-5.234680806802542\n-10.000000000000028\n-10.0",
    "crumbs": [
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>量身定制的约束、变量和目标</span>"
    ]
  },
  {
    "objectID": "dfba-cn.html",
    "href": "dfba-cn.html",
    "title": "15  在COBRApy动态通量平衡分析(dFBA)",
    "section": "",
    "text": "15.1 建立动态系统\n动态通量平衡分析将细胞外浓度的动态系统与伪稳态代谢模型耦合在一起。在本手册中，我们定义了add_dynamic_bounds(model, y)函数，即将外部代谢物浓度转换为代谢模型中边界通量的边界\ndef add_dynamic_bounds(model, y):\n    \"\"\"使用外部浓度来结合葡萄糖的摄取通量.\"\"\"\n    biomass, glucose = y  # expand the boundary species\n    glucose_max_import = -10 * glucose / (5 + glucose)\n    model.reactions.EX_glc__D_e.lower_bound = glucose_max_import\n    \n\ndef dynamic_system(t, y):\n    \"\"\"计算外部物质的时间导数.\"\"\"\n\n    biomass, glucose = y  # 扩展边界物种\n    \n    # 计算给定外部浓度下的特定交换通量。\n    with model:\n        add_dynamic_bounds(model, y)\n        \n        cobra.util.add_lp_feasibility(model)\n        feasibility = cobra.util.fix_objective_as_constraint(model)\n        lex_constraints = cobra.util.add_lexicographic_constraints(\n            model, ['Biomass_Ecoli_core', 'EX_glc__D_e'], ['max', 'max'])\n    \n    # 由于计算出的通量是具体速率，所以我们需要将它们乘以生物量浓度，以此来得到总体的交换速率。\n    fluxes = lex_constraints.values\n    fluxes *= biomass\n    \n    # 这个程序实现起来并不高效，因此我通过显示进度条来展示当前的模拟时间进程。\n    \n    if dynamic_system.pbar is not None:\n        dynamic_system.pbar.update(1)\n        dynamic_system.pbar.set_description('t = {:.3f}'.format(t))\n        \n    return fluxes\n\ndynamic_system.pbar = None\n\n\ndef infeasible_event(t, y):\n    \"\"\"\n    Determine solution feasibility.\n\n    Avoiding infeasible solutions is handled by solve_ivp's built-in event detection.\n    This function re-solves the LP to determine whether or not the solution is feasible\n    (and if not, how far it is from feasibility). When the sign of this function changes\n    from -epsilon to positive, we know the solution is no longer feasible.\n    \n    \"\"\"\n    \n    with model:\n        \n        add_dynamic_bounds(model, y)\n        \n        cobra.util.add_lp_feasibility(model)\n        feasibility = cobra.util.fix_objective_as_constraint(model)\n        \n    return feasibility - infeasible_event.epsilon\n\ninfeasible_event.epsilon = 1E-6\ninfeasible_event.direction = 1\ninfeasible_event.terminal = True",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>在COBRApy动态通量平衡分析(dFBA)</span>"
    ]
  },
  {
    "objectID": "dfba-cn.html#运行动态fba模拟",
    "href": "dfba-cn.html#运行动态fba模拟",
    "title": "15  在COBRApy动态通量平衡分析(dFBA)",
    "section": "15.2 运行动态FBA模拟",
    "text": "15.2 运行动态FBA模拟\n\nts = np.linspace(0, 15, 100)  # 所需的积分分辨率和间隔\ny0 = [0.1, 10]\n\nwith tqdm() as pbar:\n    dynamic_system.pbar = pbar\n\n    sol = solve_ivp(\n        fun=dynamic_system,\n        events=[infeasible_event],\n        t_span=(ts.min(), ts.max()),\n        y0=y0,\n        t_eval=ts,\n        rtol=1e-6,\n        atol=1e-8,\n        method='BDF'\n    )\n\nt = 5.804: : 185it [00:33,  5.50it/s]\n\n\n因为培养物的葡萄糖耗尽，模拟提前终止。这个“细胞死亡”的确切时间记录在sol.t_events。\n\nsol\n\n  message: A termination event occurred.\n  success: True\n   status: 1\n        t: [ 0.000e+00  1.515e-01 ...  5.606e+00  5.758e+00]\n        y: [[ 1.000e-01  1.090e-01 ...  8.715e-01  8.727e-01]\n            [ 1.000e+01  9.895e+00 ...  3.476e-01  2.710e-01]]\n      sol: None\n t_events: [array([ 5.802e+00])]\n y_events: [array([[ 8.728e-01,  2.518e-01]])]\n     nfev: 179\n     njev: 2\n      nlu: 14",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>在COBRApy动态通量平衡分析(dFBA)</span>"
    ]
  },
  {
    "objectID": "dfba-cn.html#绘制生物量和葡萄糖的时间表",
    "href": "dfba-cn.html#绘制生物量和葡萄糖的时间表",
    "title": "15  在COBRApy动态通量平衡分析(dFBA)",
    "section": "15.3 绘制生物量和葡萄糖的时间表",
    "text": "15.3 绘制生物量和葡萄糖的时间表\n\nax = plt.subplot(111)\nax.plot(sol.t, sol.y.T[:, 0])\nax2 = plt.twinx(ax)\nax2.plot(sol.t, sol.y.T[:, 1], color='r')\n\nax.set_ylabel('Biomass', color='b')\nax2.set_ylabel('Glucose', color='r')\n\nText(0, 0.5, 'Glucose')",
    "crumbs": [
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>在COBRApy动态通量平衡分析(dFBA)</span>"
    ]
  },
  {
    "objectID": "faq-cn.html",
    "href": "faq-cn.html",
    "title": "16  常见问题解答",
    "section": "",
    "text": "16.1 如何安装cobrapy?\n请参阅文件 INSTALL.rst\n##如何引用cobrapy?\n请引用2013年的出版物: 10.1186/1752-0509-7-74",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>常见问题解答</span>"
    ]
  },
  {
    "objectID": "faq-cn.html#如何重新命名反应或代谢物",
    "href": "faq-cn.html#如何重新命名反应或代谢物",
    "title": "16  常见问题解答",
    "section": "16.2 如何重新命名反应或代谢物?",
    "text": "16.2 如何重新命名反应或代谢物?\nTL;DR 之后使用“Model.repair”\n当重命名代谢物或反应时，会出现一些问题，因为cobra索引是基于ID的，这可能会导致错误。例如:\n\nfrom cobra.io import load_model\nmodel = load_model(\"iYS1720\")\n\nfor metabolite in model.metabolites:\n    metabolite.id = f\"test_{metabolite.id}\"\n\ntry:\n    model.metabolites.get_by_id(model.metabolites[0].id)\nexcept KeyError as e:\n    print(repr(e))\n\nModel.repair 函数将重新生成必要的索引\n\nmodel.repair()\nmodel.metabolites.get_by_id(model.metabolites[0].id)\n\n\n        \n\n\n\nMetabolite identifier\ntest_10fthf_c\n\n\nName\n10-Formyltetrahydrofolate\n\n\nMemory address\n0x16e9f8c5750\n\n\nFormula\nC20H21N7O7\n\n\nCompartment\nc\n\n\nIn 9 reaction(s)\nGARFT, MTHFC, BIOMASS_Ec_iAF1260_core_59p81M, BIOMASS_invivo, TDPFRMT, FTHFD, ULA4NFT, AICART, FMETTRS",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>常见问题解答</span>"
    ]
  },
  {
    "objectID": "faq-cn.html#如何删除基因",
    "href": "faq-cn.html#如何删除基因",
    "title": "16  常见问题解答",
    "section": "16.3 如何删除基因？",
    "text": "16.3 如何删除基因？\n这取决于你所说的删除基因到底是什么意思。\n如果要模拟基因敲除的模型，请在上下文中使用cobra.manipulation.knock_out_model_genes 函数。退出上下文时，此函数的效果将相反。\n\nmodel = load_model(\"iYS1720\")\nPGI = model.reactions.get_by_id(\"PGI\")\nprint(\"bounds before knockout:\", (PGI.lower_bound, PGI.upper_bound))\nfrom cobra.manipulation import knock_out_model_genes\nknock_out_model_genes(model, [\"STM4221\"])\nprint(\"bounds after knockouts\", (PGI.lower_bound, PGI.upper_bound))\n\nbounds before knockout: (-1000.0, 1000.0)\nbounds after knockouts (0, 0)\n\n\n如果你想从模型中去除一个基因的所有痕迹，这要困难得多，因为这需要改变涉及该基因的反应的所有 gene_reaction_rule 字符串。",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>常见问题解答</span>"
    ]
  },
  {
    "objectID": "faq-cn.html#如何更改反应的可逆性",
    "href": "faq-cn.html#如何更改反应的可逆性",
    "title": "16  常见问题解答",
    "section": "16.4 如何更改反应的可逆性？",
    "text": "16.4 如何更改反应的可逆性？\nReaction.reversibility 是cobra中的一个属性，在从下界和上界请求时计算。\n\nmodel = load_model(\"iYS1720\")\nmodel.reactions.get_by_id(\"PGI\").reversibility\n\nTrue\n\n\n尝试直接设置它将导致错误或警告：\n\ntry:\n    model.reactions.get_by_id(\"PGI\").reversibility = False\nexcept Exception as e:\n    print(repr(e))\n\nd:\\ProgramData\\anaconda3\\Lib\\site-packages\\cobra\\core\\reaction.py:810: UserWarning: Setting reaction reversibility is ignored\n  warn(\"Setting reaction reversibility is ignored\")\n\n\n改变可逆性的方法是改变边界，使反应不可逆。\n\nmodel.reactions.get_by_id(\"PGI\").lower_bound = 10\nmodel.reactions.get_by_id(\"PGI\").reversibility\n\nFalse",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>常见问题解答</span>"
    ]
  },
  {
    "objectID": "faq-cn.html#如何从-cobra-模型生成-lp-文件",
    "href": "faq-cn.html#如何从-cobra-模型生成-lp-文件",
    "title": "16  常见问题解答",
    "section": "16.5 如何从 COBRA 模型生成 LP 文件？",
    "text": "16.5 如何从 COBRA 模型生成 LP 文件？\n\n16.5.1 关于基于 optlang 的求解器\n使用 optlang 求解器，模型的 LP 公式通过其字符串表示获得。所有求解器的行为方式都相同。\n\nwith open('test.lp', 'w') as out:\n    out.write(str(model.solver))\n\n\n\n16.5.2 我如何将通量解形象化?\n请浏览我们网站上的 visualization packages以获取最新的工具列表。",
    "crumbs": [
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>常见问题解答</span>"
    ]
  }
]